//@author: a0125474e



	/**
	 * origin: D:\install location\java\work\CS2103 PISTA\src\pista\parser\MainParser.java
	 */

	/**This method checks the tokens for the Set file location command
	 * Parameters: Object of MainParser
	 * 				String array - contains all parameters
	 * Return:		Boolean 
	 * 				True if the tokens are correct
	 * 				False if the tokens are wrong 
	 * **/
	private boolean checkSetTokens(MainParser mp, String[] tokens){
		String getType = "";
		String getFileLocation = "";

		if(tokens == null){
			mp.setMessage(Constants.PARSER_MESSAGE_INVALID_TOKEN_LENGTH);
			return false;
		}

		if(tokens.length <= Constants.LENGTH_ONE){ //must have at least 2
			mp.setMessage(Constants.LOGIC_INVALID_SET_COMMAND_LENGTH);
			return false;
		}

		getType = tokens[Constants.SET_TYPE_INDEX]; //index of type is 0
		if(!getType.equalsIgnoreCase(Constants.PARSER_SET_TYPE_FILE_LOCATION)){
			mp.setMessage(Constants.LOGIC_INVALID_SET_COMMAND_TYPE);	
			return false;
		}

		getFileLocation = tokens[Constants.SET_VALUE_INDEX];
		if(!TokenValidation.isFileNameValid(getFileLocation)){
			mp.setMessage(Constants.LOGIC_INVALID_SET_FILE_NAME);
			return false;
		}

		mp.setTokens(tokens);
		return true;

	}
	
	// End of segment: D:\install location\java\work\CS2103 PISTA\src\pista\parser\MainParser.java





	/**
	 * origin: D:\install location\java\work\CS2103 PISTA\src\pista\parser\MainParser.java
	 */

	/**This method converts a string into Int
	 * Parameters: String - input
	 * Return:		Integer - converted string representation in int
	 * **/
	public static int stringToInt(String input){
		return Integer.parseInt(input.trim());
	}

	// End of segment: D:\install location\java\work\CS2103 PISTA\src\pista\parser\MainParser.java





	/**
	 * origin: D:\install location\java\work\CS2103 PISTA\src\pista\storage\Storage.java
	 */

package pista.storage;

import java.io.BufferedWriter;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.FileWriter;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.nio.channels.FileChannel;
import java.nio.file.Files;
import java.nio.file.LinkOption;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.nio.file.StandardCopyOption;
import java.util.ArrayList;

import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;
import javax.xml.transform.OutputKeys;
import javax.xml.transform.Transformer;
import javax.xml.transform.TransformerFactory;
import javax.xml.transform.dom.DOMSource;
import javax.xml.transform.stream.StreamResult;

import org.w3c.dom.Document;
import org.w3c.dom.Element;
import org.w3c.dom.Node;
import org.w3c.dom.NodeList;

import pista.Constants;
import pista.log.CustomLogging;
import pista.logic.Task;
import pista.parser.MainParser;

public class Storage {

	private static final Storage mStorage = new Storage();
	
	private static int max_number_of_tasks = 0;
	private static String data_file_location = "";
	
	//Assertion
	private static final String ASSERT_ARRAY_LIST_TASK_NULL_MESSAGE = "List of task is not initialize";
	private static final String ASSERT_XML_FILE_PATH_EMPTY_MESSAGE = "XML file path is empty";
	private static final String ASSERT_XML_DOCUMENT_NULL_MESSAGE = "XML document is not initialize";
	private static final String ASSERT_XML_DOCUMENT_ROOT_NULL_MESSAGE = "XML root is undefined or null";
	private static final String ASSERT_XML_NODE_NULL_MESSAGE = "XML node is undefined or null";
	private static final String ASSERT_XML_NODE_LIST_NULL_MESSAGE = "XML node list is undefined or null";
	
	//Logging
	private static final String LOG_STORAGE_LOAD_SUCCESS = "Successfully Load XML file to task list";
	private static final String LOG_STORAGE_WRITE_XML_FILE_SUCCESS = "Successfully write into XML file";	
	private static final String LOG_STORAGE_SAVE_SUCCESS = "Successfully save XML file";
	private static final String LOG_STORAGE_SAVE_FAILURE = "Fail to save XML file";
	private static final String LOG_STORAGE_GET_NEXT_AVAILABLE_ID_SUCCESS = "Successfully get next available ID";
		
	private ArrayList<Task> taskList = null;
	private ArrayList<String> historyList = new ArrayList<String>();
	private static CustomLogging mLog = null;
	
	/**
	 * Don't allow to create a new instance
	 * **/
	private Storage(){} 
	
	/**This method will return the instance of Storage class
	 *and initialize Logging object 
	 ***/
	public static Storage getInstance(){ 
		if(mLog == null){
			mStorage.initLogging();
		}
		return mStorage;
	}
	
	/**Initialize Logging
	 * **/
	public boolean initLogging(){
		try{
			mLog = CustomLogging.getInstance(Storage.class.getName());
			return true;
		}catch(Exception e){
			e.printStackTrace();
			return false;
		}	
	}
	
	/**This method will load data from XML file
	 * **/
	public boolean load(){
		taskList = XmltoTable(getDataFileLocation());	
		if(taskList != null){
			return true;
		}
		return false;
	}
	
	/**This methodd will save from list to XML file
	 * **/
	public boolean save(){
		boolean isSaved = false;
		isSaved = tableToXml(getDataFileLocation(), taskList);
		return isSaved;
	}
		
	/**This method will write default string to the new XML file
	 * Parameters:	newPath - the new xml file path
	 * Return: 		boolean - true or false indicate success or fail
	 * **/
	public boolean writeNewXmlFile(String newPath){
		//filepath exist
		try {
			//String newXmlString = XML_DEFAULT_STRING.replace("[new_file_path]", newPath);
			File file = new File(newPath);

			if(!file.exists()){
				file.createNewFile();
			}
			
			//exist and either length is 0 or not valid xml format
			FileWriter fileWriter = new FileWriter(file, false); //overwrite the file
			
			BufferedWriter bufferFileWriter  = new BufferedWriter(fileWriter);
	        fileWriter.append(Constants.XML_DEFAULT_STRING); //write the default xml string
	        bufferFileWriter.close();
	        
			fileWriter.close();

			return true;
		} catch (IOException e) {
			mLog.logSevere(e.getMessage());
			e.printStackTrace();
			return false;
		}
	}
	
	/**This method will validate the given file by checking the important XML nodes
	 * Parameters:	xmlFilePath - the xml file path
	 * Return: 		boolean - true or false indicate valid or invalid
	 * **/
	public boolean isFileFormatValid(String xmlFilePath){
		//Do a small test on e selected xml file
		try{
			File mXmlFile = new File(xmlFilePath);
			DocumentBuilderFactory dbFactory = DocumentBuilderFactory.newInstance();
			DocumentBuilder dBuilder = dbFactory.newDocumentBuilder();
			Document doc = dBuilder.parse(mXmlFile);
			
			Node nRoot = null;
			nRoot = doc.getDocumentElement(); //get root
			NodeList nTotalList = null;
			nTotalList = doc.getElementsByTagName(Constants.NODE_TOTAL_TASK_TAG); 
			Node nTotalValue = null;
			nTotalValue = nTotalList.item(0);
			NodeList nTaskList = null;
			nTaskList = doc.getElementsByTagName(Constants.NODE_TASK_TAG); 
			
			if(isNodeNull(nRoot) || isNodeNull(nTotalValue) || isNodeListNull(nTotalList) || isNodeListNull(nTaskList)){
				return false; //not valid XML format
			}

		}catch (Exception e){
			mLog.logSevere(e.getMessage());
			e.printStackTrace();
			return false;
		}
		
		return true;
	}
	
	/**This method will check if the given file path exist
	 * Parameters:	filePath - the xml file path
	 * Return: 		boolean - true or false indicate exist or non-exist
	 * **/
	public boolean isFileExist(String filePath){
		try{
			File file = new File(filePath);
			if(file.exists()){
				return true;
			}
			//not exist
			return false;
			
		}catch(Exception e){
			mLog.logSevere(e.getMessage());
			e.printStackTrace();
			return false;
		}
	}
	
	/**This method will check if the given file contains any value
	 * Parameters:	filePath - the xml file path
	 * Return: 		boolean - true or false indicate empty or not empty
	 * **/
	public boolean isFileEmpty(String filePath){
		
		try {
			File file = new File(filePath);
			FileInputStream fis = new FileInputStream(file);  

			int b = fis.read();
			if (b == -1)  {
				fis.close();
				return true; //is empty
			}
			
			fis.close();
			return false;
		
		} catch (IOException e) {
			mLog.logSevere(e.getMessage());
			e.printStackTrace();
			return true;
		}  
	
	} 
	
	/**This method will get the total current number of tasks
	 * Return:	int - number of tasks
	 * **/
	 public int getMaxNumberOfTasks(){
		 return max_number_of_tasks;
	 }
	 
	 /**This method will get the next usable task ID
		 * Return:	int - next non-recycled ID
		 * **/
	 public int getNextAvailableID(){
		 //return max_number_of_tasks + 1;
		 int lastID = 0;
		 
		 try{
			 assert(taskList != null) : ASSERT_ARRAY_LIST_TASK_NULL_MESSAGE;
			 
			 if(taskList != null){
				for(Task mTask : taskList){
					if(mTask.getID() > lastID){
						lastID = mTask.getID();
					}//end if 
				}//end for 
			 }//end if 
			  
			 mLog.logInfo(LOG_STORAGE_GET_NEXT_AVAILABLE_ID_SUCCESS);
			 return lastID + 1;
			 
		 }catch(AssertionError e){
			 mLog.logSevere(e.getMessage());
			 return 0;
		 }
		 
	 }
	 
	 /**This method will return current saved file location
	 * Return:	String - file location
	 * **/	 
	 public String getDataFileLocation(){
		 return data_file_location;
	 }
	 
	 /**This method will initialize the task list
	 * Return:	boolean - true
	 * **/
	 public boolean initTaskList(){
		 taskList = new ArrayList<Task>();
		 return true;
	 }
	 
	 public ArrayList<Task> getTaskList(){
		 if(this.taskList == null){
			 taskList = new ArrayList<Task>();
		 }
		 return taskList;
	 }
	 
	 public void setTaskList(ArrayList<Task> tl){
		 taskList = new ArrayList<Task>(tl);
	 }
	 
	 public ArrayList<String> getHistoryList(){
		 return historyList;
	 }
	 
	 public void setDataFileLocation(String location){
		 data_file_location = location;
	 }
	 
	 /**This method will copy entirely from source to destination file
	  * Parameters:		sourceFilePath - valid source file path
	  * 				destinationFilePath - valid destination file path
	  * Return:			boolean - true or false - indicate success or fail
	  * **/
	 public boolean copyFile(String sourceFilePath, String destinationFilePath){
		 try{
			 
			 Path original = Paths.get(sourceFilePath); //original file 
			 Path destination = Paths.get(destinationFilePath); //new file 
			 Files.copy(original, destination, StandardCopyOption.REPLACE_EXISTING);
			 
			 return true;
		 }catch(IOException e){
			 mLog.logSevere(e.getMessage());
			 e.printStackTrace();
			 return false;
		 }
	 }
	 
	/**This method will check if the XML node is null
	 * Parameters:	n - a xml node
	 * Return: 		boolean - true or false indicate null or not null
	 * **/
	private boolean isNodeNull(Node n){
		if(n == null){
			return true;
		}
		return false;
	}
	
	/**This method will check if the XML node list collection is null
	 * Parameters:	n - a xml node list
	 * Return: 		boolean - true or false indicate null or not null
	 * **/
	private boolean isNodeListNull(NodeList n){
		if(n == null){
			return true;
		}
		return false;
	}
	

	/**This method will populate XML file from the task list
	 * Parameters:	xmlFilePath - given XML file path
	 * 				mArrayTask - given array list of tasks
	 * Return: 		boolean - true or false indicate success or fail
	 * **/
	private boolean tableToXml(String xmlFilePath, ArrayList<Task> mArrayTask){
		boolean isSaved = false;
		boolean isAllNodesRemove = false;
		
		try{	
			//assertion
			assert(mArrayTask != null) : ASSERT_ARRAY_LIST_TASK_NULL_MESSAGE;
			
			//start of XML
			Node nRoot = null;
			Node nTask = null;
			Node nTotal = null;

			File mXmlFile = new File(xmlFilePath);
			DocumentBuilderFactory dbFactory = DocumentBuilderFactory.newInstance();
			DocumentBuilder dBuilder = dbFactory.newDocumentBuilder();
			Document doc = dBuilder.parse(mXmlFile);
			
			normalize(doc);
			
			//remove all nodes from XML
			isAllNodesRemove = xmlRemoveAllTask(doc);
			if(!isAllNodesRemove){ //if failed to remove all task nodes
				return false;
			}
			
			//create a new root node
			nRoot = doc.createElement(Constants.NODE_ROOT_TAG);
			
			//get the latest tasklist size as the total number of tasks
			max_number_of_tasks = mArrayTask.size();
			
			//add total number of tasks
			nTotal = doc.createElement(Constants.NODE_TOTAL_TASK_TAG);
			createNode(nTotal, Constants.NODE_TOTAL_TASK_VALUE_TAG, convertIntToString(max_number_of_tasks));//add value to total_task
			//add total node to root
			nRoot.appendChild(nTotal);
			
			//add task nodes
			for(Task mTask : mArrayTask){
				//new task node
				nTask = doc.createElement(Constants.NODE_TASK_TAG);

				//create new node method
				createNode(nTask, Constants.NODE_TASK_ID_TAG, convertIntToString(mTask.getID()));
				createNode(nTask, Constants.NODE_TASK_TITLE_TAG, mTask.getTitle());
				createNode(nTask, Constants.NODE_TASK_START_MILLISECOND_TAG, convertLongToString(mTask.getStartMilliseconds()));
				createNode(nTask, Constants.NODE_TASK_END_MILLISECOND_TAG, convertLongToString(mTask.getEndMilliseconds()));
				createNode(nTask, Constants.NODE_TASK_IS_DONE_TAG, convertBooleanToString(mTask.getIsDone()));
				createNode(nTask, Constants.NODE_TASK_CATEGORY_TAG, mTask.getCategory());
				createNode(nTask, Constants.NODE_TASK_PRIORITY_TAG, mTask.getPriority());
				createNode(nTask, Constants.NODE_TASK_REMINDER_TIME_TAG, convertLongToString(mTask.getReminder()));
				
				//add task node to root
				nRoot.appendChild(nTask);
				
			}//end for 
			
			//add root node to doc
			doc.appendChild(nRoot);
			
			//Save the document
			isSaved = saveXml(doc, xmlFilePath);			
	
			if (isSaved){
				mLog.logInfo(LOG_STORAGE_SAVE_SUCCESS);
				return true;
			}else{
				mLog.logWarning(LOG_STORAGE_SAVE_FAILURE);
				return false;
			}
			
		}catch(AssertionError e){
			mLog.logSevere(e.getMessage());
			e.printStackTrace();
			return false;
			
		}catch(Exception e){
			mLog.logSevere(e.getMessage()); //logging
			e.printStackTrace();
			return false;
		}
	
	}
	
	
	
	/**This method will populate task list from the XML file
	 * Parameters:	xmlFilePath - given XML file path
	 * Return: 		boolean - true or false indicate success or fail
	 * **/
	private ArrayList<Task> XmltoTable(String xmlFilePath){
		
		ArrayList<Task> mArrayTask = new ArrayList<Task>();
		
		try{
			//assertion
			assert(!(xmlFilePath.equals("")) || !(xmlFilePath.isEmpty())) : ASSERT_XML_FILE_PATH_EMPTY_MESSAGE;
			
			File mXmlFile = new File(xmlFilePath);
			DocumentBuilderFactory dbFactory = DocumentBuilderFactory.newInstance();
			DocumentBuilder dBuilder = dbFactory.newDocumentBuilder();
			Document doc = dBuilder.parse(mXmlFile);
			
			normalize(doc);
			
			//Get total num of tasks from XML
			NodeList nTotalList = doc.getElementsByTagName(Constants.NODE_TOTAL_TASK_TAG);
			Node nTotalValue = nTotalList.item(0);
			max_number_of_tasks = convertStringToInt(nTotalValue.getTextContent()); //get total number
			
			NodeList nList = doc.getElementsByTagName(Constants.NODE_TASK_TAG);
			
			for (int temp = 0; temp < nList.getLength(); temp++) {
				 
				Node nNode = nList.item(temp);
		 
				if (nNode.getNodeType() == Node.ELEMENT_NODE) {
		 
					Element eElement = (Element) nNode;
		 
					Task mTask = null;
					
					int m_id = 0;
					String m_title = "";
					String m_start_millisecond = "";
					String m_end_millisecond = "";
					String m_start_time = "";
					String m_end_time = "";
					String m_start_date = "";
					String m_end_date = "";
					String m_category = "";
					String m_priority = "";
					boolean m_is_done = false;
					String m_reminder = "";
					
					
					m_id = Integer.parseInt(eElement.getElementsByTagName(Constants.NODE_TASK_ID_TAG).item(0).getTextContent());
					m_title = eElement.getElementsByTagName(Constants.NODE_TASK_TITLE_TAG).item(0).getTextContent();
					m_start_millisecond = eElement.getElementsByTagName(Constants.NODE_TASK_START_MILLISECOND_TAG).item(0).getTextContent();
					m_end_millisecond = eElement.getElementsByTagName(Constants.NODE_TASK_END_MILLISECOND_TAG).item(0).getTextContent();
					
					m_start_time = MainParser.convertMillisecondToTime(Long.valueOf(m_start_millisecond));
					m_end_time = MainParser.convertMillisecondToTime(Long.valueOf(m_end_millisecond));
					m_start_date = MainParser.convertMillisecondToDate(Long.valueOf(m_start_millisecond));
					m_end_date = MainParser.convertMillisecondToDate(Long.valueOf(m_end_millisecond));
							
					m_is_done = Boolean.parseBoolean(eElement.getElementsByTagName(Constants.NODE_TASK_IS_DONE_TAG).item(0).getTextContent());
					m_category = eElement.getElementsByTagName(Constants.NODE_TASK_CATEGORY_TAG).item(0).getTextContent();
					m_priority = eElement.getElementsByTagName(Constants.NODE_TASK_PRIORITY_TAG).item(0).getTextContent();
					m_reminder = eElement.getElementsByTagName(Constants.NODE_TASK_REMINDER_TIME_TAG).item(0).getTextContent();
					
					//create new task object
					mTask = new Task(m_id, 
									m_title, 
									convertStringToLong(m_start_millisecond),
									convertStringToLong(m_end_millisecond),
									m_start_time,
									m_start_date,
									m_end_time,
									m_end_date,
									m_category,
									m_priority,
									m_is_done,
									convertStringToLong(m_reminder));
					
					mArrayTask.add(mTask); //add new task into table
					
				}//end if 
			}//end for
			
			mLog.logInfo(LOG_STORAGE_LOAD_SUCCESS);

		}catch(AssertionError e){
			mLog.logSevere(e.getMessage());
			e.printStackTrace();
			mArrayTask = null;
			
		}catch(Exception e){
			mLog.logSevere(e.getMessage());
			e.printStackTrace();
			mArrayTask = null;
		}//end try
		
		return mArrayTask;
		
	}//end XMLtoJava
	
	/**This method will add a child node to the parent node of XML
	 * Parameters:	parent - parent XML node
	 * 				tagName - child XML node name
	 * 				value - child XML node value
	 * **/
	private void createNode(Node parent, String tagName, String value){
		Document doc = parent.getOwnerDocument();
		//create a new node
		Node mNode  = doc.createElement(tagName);
		//set content of the node
		mNode.setTextContent(value);
		//add new node to the parent node
		parent.appendChild(mNode);
	}	

	/**This method will save XML document
	 * Parameters:	doc - XML document
	 * 				xmlFilePath - given XML file path
	 * Return: 		boolean - true or false indicate success or fail
	 * **/
	private boolean saveXml(Document doc, String xmlFilePath){
		//Save the document
		try{
			
			//assertion
			assert(doc != null): ASSERT_XML_DOCUMENT_NULL_MESSAGE;
			assert(!(xmlFilePath.equals("")) || !(xmlFilePath.isEmpty())) :	ASSERT_XML_FILE_PATH_EMPTY_MESSAGE;
			
			TransformerFactory transformerFactory = TransformerFactory.newInstance();
			Transformer transformer = transformerFactory.newTransformer();
			DOMSource source = new DOMSource(doc);
			StreamResult result = new StreamResult(new File(xmlFilePath));
			transformer.transform(source, result);
			transformer.setOutputProperty(OutputKeys.INDENT, "yes"); 
			
			mLog.logInfo(LOG_STORAGE_WRITE_XML_FILE_SUCCESS);
			
			return true;
			
		}catch(AssertionError e){
			mLog.logSevere(e.getMessage());
			e.printStackTrace();
			return false;
			
		}catch(Exception e){
			mLog.logSevere(e.getMessage());
			e.printStackTrace();
			return false;		
		}//end try
		
	}//end saveXML
	
	/**This method will remove all child nodes from the given node
	 * Parameters:	node - given node that might contains child nodes
	 * Return: 		boolean - true or false indicate success or fail
	 * **/
	private boolean xmlRemoveAllTask(Node node) {
		try{
			assert(node != null) : ASSERT_XML_NODE_NULL_MESSAGE;
			NodeList mNodeList = node.getChildNodes();
			assert(mNodeList != null) : ASSERT_XML_NODE_LIST_NULL_MESSAGE;
			
			if(mNodeList != null){
				for(int i=0; i< mNodeList.getLength(); i++){
					Node n = mNodeList.item(i);  
					node.removeChild(n);
				}//end for	
			}
			
			return true;
			
		}catch(AssertionError e){
			mLog.logSevere(e.getMessage());
			return false;
			
		}catch(Exception e){
			mLog.logSevere(e.getMessage());
			return false;
		}
	}//end removeAllFromXML
	 	
	/**This method will restructure the string value in a XML node
	 * Parameters:	doc - XML document
	 * **/
	private void normalize(Document doc){
		 try{
			 assert(doc != null) : ASSERT_XML_DOCUMENT_NULL_MESSAGE;
			 
			 if(doc != null){
				 Element root = doc.getDocumentElement();
				 assert(root != null) : ASSERT_XML_DOCUMENT_ROOT_NULL_MESSAGE;
				 root.normalize();	
			 }
			 
		 }catch(AssertionError e){
			 mLog.logWarning(e.getMessage());
		 }	 	 
	 }

	 /*============================= Conversion =============================*/
	 private String convertIntToString(int input){
		 return String.valueOf(input);
	 }
	 
	 private int convertStringToInt(String input){
		 return Integer.parseInt(input);
	 }
	 
	 private String convertBooleanToString(boolean input){
		 return String.valueOf(input);
	 }
	 
	 private String convertLongToString(long input){
		 return String.valueOf(input);
	 }
	 
	 private long convertStringToLong(String input){
		 return Long.valueOf(input);
	 }

}//end class



	// End of segment: D:\install location\java\work\CS2103 PISTA\src\pista\storage\Storage.java





	/**
	 * origin: D:\install location\java\work\CS2103 PISTA\src\pista\ui\TaskListCell.java
	 */

package pista.ui;

import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.time.LocalDate;
import java.time.format.DateTimeFormatter;
import java.util.Calendar;

import javafx.event.ActionEvent;
import javafx.event.EventHandler;
import javafx.geometry.HPos;
import javafx.geometry.Insets;
import javafx.geometry.Pos;
import javafx.geometry.VPos;
import javafx.scene.control.Button;
import javafx.scene.control.DatePicker;
import javafx.scene.control.Label;
import javafx.scene.control.ListCell;
import javafx.scene.control.RadioButton;
import javafx.scene.control.TextArea;
import javafx.scene.control.TextField;
import javafx.scene.control.ToggleGroup;
import javafx.scene.control.Tooltip;
import javafx.scene.image.Image;
import javafx.scene.image.ImageView;
import javafx.scene.input.MouseEvent;
import javafx.scene.layout.ColumnConstraints;
import javafx.scene.layout.GridPane;
import javafx.scene.layout.HBox;
import javafx.scene.layout.RowConstraints;
import javafx.scene.layout.VBox;
import javafx.scene.text.TextAlignment;
import javafx.util.StringConverter;

import org.controlsfx.control.Notifications;
import org.controlsfx.control.PopOver;

import pista.Constants;
import pista.logic.Logic;
import pista.logic.Task;
import pista.parser.MainParser;
import pista.parser.TokenValidation;

public class TaskListCell extends ListCell<Task> {
	private Logic mLogic = null;

    private String DISPLAY_START_DATE_TIME = "From [datetime]"; 
    private String DISPLAY_END_DATE_TIME = "To [datetime]";
    private final int MAX_CHARACTER_IN_TITLE = 45;
    
    private UIController mUIParent = null;
	private GridPane grid = null;
	private VBox vBoxDateTime = new VBox();
	private VBox vBoxButtonIsDone = new VBox();
	
	private Label lblID = new Label();
    private Label lblTitle = new Label();
    private Label lblDateTime = new Label();
    
    private Button btnIsDone = new Button();
    private Button btnAlarm = new Button();
    private Button btnPriority = new Button();
    private Button btnEdit = new Button();
    private Button btnDelete = new Button();
    
    private PopOver mPopOverAlarm = null;
    private PopOver mPopOverPriority = null;
    private PopOver mPopOverEdit = null;
    
    private TextArea txtAreaPopOverEditTaskTitle = null;
    private TextField txtPopOverAlarmHourField = null;
    private TextField txtPopOverAlarmMinField = null;
    private TextField txtPopOverEditStartHourField = null;
    private TextField txtPopOverEditStartMinField = null;
    private TextField txtPopOverEditEndHourField = null;
    private TextField txtPopOverEditEndMinField = null; 
    private DatePicker datePickerPopOverEditStartDate = null;
    private DatePicker datePickerPopOverEditEndDate = null;
    private DatePicker datePickerPopOverAlarm = null;
    private Label lblPopOverAlarmMessage = null;
    private Label lblPopOverPriorityMessage = null;
    private Label lblPopOverEditMessage = null;
    private Label lblPopOverTimeTip  = null;
    private Label lblPopOverTitle = null;
    private Label lblPopOverDateTitle = null;
    private Label lblPopOverTimeTitle = null;
    private Label lblPopOverColon = null; 
    private ToggleGroup priorityGroup = null;
    
    private String getID = "";
    private String getTitle = "";
    private String getCategory = "";
    private String getStartDate = "";
    private String getEndDate = "";
    private String getStartTime = "";
    private Long getStartMillisecond = 0L;
    private Long getEndMillisecond = 0L;
    private String getEndTime = "";
    private boolean getIsDone = false;
    private Long getRemainder = 0L;
    private String getPriority = "";
    
    //Time format: HH:M
    //Date format: d/M/yyyy
    private String editPriorityCommand = "priority [id] -[level]";
    private String editAlarmCommand = "remind [id] -[start_date] -[start_time]";
    private String offAlarmCommand = "remind [id] -off";
    private String deleteCommand = "delete [id]";
    private String editTaskcommand = "edit [id] -[new_title] -[new_start_date] -[new_start_time] -[new_end_date] -[new_end_time]";
    
    private final double PREF_GRID_HEIGHT = 70.0;
    private final double BUTTON_IS_DONE_WIDTH = 70.0;
    private final double BUTTON_IS_DONE_HEIGHT = this.PREF_GRID_HEIGHT - 4.0;
    private final double BUTTON_IMAGE_WIDTH = 55.0;
    private final double BUTTON_IMAGE_HEIGHT = this.PREF_GRID_HEIGHT - 4.0;
	
    @Override
	public void updateItem(Task mTask, boolean empty){
		super.updateItem(mTask,  empty);
		if(empty || mTask == null){
			clearContent();
			return;
		}else {		
			addContent(mTask);
		}//end if 
	}//end updateItem
    
    /**Default constructor
     * **/
    public TaskListCell() {
    	super();
        initGrid(); 
        initButtonIsDone();
        initButtonImage();
        setButtonEditStyle();
        setButtonDeleteStyle();
        setLabelIDStyle(false);
        setLabelTitleStyle(false);
        setLabelDateTimeStyle(false);
        initVBoxIsDone();
        addControlsToVBoxDateTime();
        addControlsToVBoxIsDone();
        addControlsToGrid();            
    }
    
    /**This method set the parent of this cell which is UIController
     * **/
    public void setUIParent(UIController ui){
		mUIParent = ui;
	}
    
    /**Initialize Logic class in this class
     * **/
	public boolean initLogic(){
		try{
			this.mLogic = Logic.getInstance();
			return true;
		}catch(Exception e){
			e.printStackTrace();
			return false;
		}
	}

    /**This method configure the grid which is the skeleton for the cell
     * **/
    private void initGrid() {
    	//these total width is 100%
    	final double hGap = 0.0;
    	final double vGap = 0.0;
    	final double colMarkDonePercentWidth = 8.0;
        final double colIDPercentWidth = 5.0;
        final double colTitlePercentWidth = 42.0;
        final double colEditPercentWidth = 7.0;
        final double colPriorityPercentWidth = 7.0;
    	final double colAlarmPercentWidth = 7.0;
    	final double colDateTimePercentWidth = 20.0;
    	final double colDeletePercentWidth = 4.0;
    	
    	this.grid = new GridPane();
    	this.grid.setHgap(hGap);
        this.grid.setVgap(vGap);
        this.grid.setPadding(new Insets(0, 0, 0, 0));
        this.grid.setPrefHeight(PREF_GRID_HEIGHT);

        ColumnConstraints colMarkDone = new ColumnConstraints(); //check box
        colMarkDone.setPercentWidth(colMarkDonePercentWidth); // mark done/undone
        colMarkDone.setHalignment(HPos.CENTER);
        
        ColumnConstraints colID = new ColumnConstraints(); //ID
        colID.setPercentWidth(colIDPercentWidth);
        colID.setHalignment(HPos.CENTER);
        
        ColumnConstraints colTitle = new ColumnConstraints(); //title
        colTitle.setPercentWidth(colTitlePercentWidth);
        colTitle.setHalignment(HPos.LEFT);
        
        ColumnConstraints colEdit = new ColumnConstraints(); //Edit
        colEdit.setPercentWidth(colEditPercentWidth);
        colEdit.setHalignment(HPos.RIGHT);
        
        ColumnConstraints colPriority = new ColumnConstraints(); // priority
        colPriority.setPercentWidth(colPriorityPercentWidth);
        colPriority.setHalignment(HPos.CENTER);
        
        ColumnConstraints colAlarm = new ColumnConstraints(); // alarm
        colAlarm.setPercentWidth(colAlarmPercentWidth);
        colAlarm.setHalignment(HPos.LEFT);
        
        ColumnConstraints colDateTime = new ColumnConstraints(); //date time
        colDateTime.setPercentWidth(colDateTimePercentWidth);
        colDateTime.setHalignment(HPos.RIGHT);
        
        ColumnConstraints colDelete = new ColumnConstraints(); //delete
        colDelete.setPercentWidth(colDeletePercentWidth);
        colDelete.setHalignment(HPos.RIGHT);
        
        
        RowConstraints row1 = new RowConstraints();
        row1.setValignment(VPos.CENTER);
        row1.setPrefHeight(70.0);
        this.grid.getRowConstraints().addAll(row1);
        
        //colBoxColor
        this.grid.getColumnConstraints().addAll(colMarkDone, colID, colTitle, colEdit, colPriority, colAlarm, colDateTime, colDelete);  
    }
    
    /**This method close the pop over priority
	 * **/
    public boolean closePopOverPriority(){
    	if(this.mPopOverPriority != null){
    		if(this.mPopOverPriority.isShowing()){
    			this.mPopOverPriority.hide();
    			return true;
    		}
    	}
    	return false;
    }
    
    /**This method close the pop over alarm
   	 * **/
    public boolean closePopOverAlarm(){
    	if(this.mPopOverAlarm != null){
    		if(this.mPopOverAlarm.isShowing()){
    			this.mPopOverAlarm.hide();
    			return true;
    		}
    	}
    	return false;
    }
    
    /**This method close the pop over edit
   	 * **/
    public boolean closePopOverEdit(){
    	if(this.mPopOverEdit != null){
    		if(this.mPopOverEdit.isShowing()){
    			this.mPopOverEdit.hide();
    			return true;
    		}
    	}
    	return false;
    }
    
    /**This method set the cell background
     * **/
    private void setCellBackground(boolean isDone){
    	getStyleClass().removeAll(Constants.CSS_CELL_BACKGROUND_IS_DONE, Constants.CSS_CELL);
   
    	if(isDone){
    		getStyleClass().add(Constants.CSS_CELL_BACKGROUND_IS_DONE);
    	}else{
    		getStyleClass().add(Constants.CSS_CELL);
    	}
    }
    
    /**This method initialize button is done
     * **/
    private void initButtonIsDone(){
    	this.btnIsDone.addEventFilter(MouseEvent.MOUSE_CLICKED, btnIsDoneEventHandler);
    	this.btnIsDone.setPrefSize(this.BUTTON_IS_DONE_WIDTH, this.BUTTON_IS_DONE_HEIGHT);
    } 
    
    /**This method initialize buttons (e.g. Alarm, Priority, Edit, Delete)
     * **/
    private void initButtonImage(){
    	initButtonAlarm();
    	initButtonPriority();
    	initButtonEdit();
    	initButtonDelete();
    }
    
    /**This method initialize button alarm
     * **/
    private void initButtonAlarm(){
    	this.btnAlarm.setPrefSize(BUTTON_IMAGE_WIDTH, BUTTON_IMAGE_HEIGHT);
    	this.btnAlarm.setMinSize(BUTTON_IMAGE_WIDTH, BUTTON_IMAGE_HEIGHT);
    	this.btnAlarm.setMaxSize(BUTTON_IMAGE_WIDTH, BUTTON_IMAGE_HEIGHT);
    	this.btnAlarm.addEventFilter(MouseEvent.MOUSE_CLICKED, this.btnShowAlarmEventHandler);
    }
    
    /**This method initialize button priority
     * **/
    private void initButtonPriority(){
    	this.btnPriority.setPrefSize(BUTTON_IMAGE_WIDTH, BUTTON_IMAGE_HEIGHT);
    	this.btnPriority.setMinSize(BUTTON_IMAGE_WIDTH, BUTTON_IMAGE_HEIGHT);
    	this.btnPriority.setMaxSize(BUTTON_IMAGE_WIDTH, BUTTON_IMAGE_HEIGHT);
    	this.btnPriority.addEventFilter(MouseEvent.MOUSE_CLICKED, this.btnShowPriorityEventHandler);
    }
    
    /**This method initialize button edit
     * **/
    private void initButtonEdit(){
    	this.btnEdit.setPrefSize(BUTTON_IMAGE_WIDTH, BUTTON_IMAGE_HEIGHT);
    	this.btnEdit.setMinSize(BUTTON_IMAGE_WIDTH, BUTTON_IMAGE_HEIGHT);
    	this.btnEdit.setMaxSize(BUTTON_IMAGE_WIDTH, BUTTON_IMAGE_HEIGHT);
    	this.btnEdit.addEventFilter(MouseEvent.MOUSE_CLICKED, this.btnPriorityEditEventHandler);
    }
    
    /**This method initialize button delete
     * **/
    private void initButtonDelete(){
    	double width = 30.0;
    	this.btnDelete.setPrefSize(width, BUTTON_IMAGE_HEIGHT);
    	this.btnDelete.setMinSize(width, BUTTON_IMAGE_HEIGHT);
    	this.btnDelete.setMaxSize(width, BUTTON_IMAGE_HEIGHT);
    	this.btnDelete.addEventFilter(MouseEvent.MOUSE_CLICKED, this.btnDeleteEventHandler);
    }
    
    /**This method init vertical box is done
     * **/
    private void initVBoxIsDone(){
    	this.vBoxButtonIsDone.setPadding(new Insets(0, 0, 0, 0));
    }
    
    /**This method set button alarm style
     * **/
    private void setButtonAlarmStyle(Long reminder, boolean isDone){
    	btnAlarm.getStyleClass().removeAll(Constants.CSS_BUTTON_ALARM_SET, Constants.CSS_BUTTON_ALARM_NOT_SET);
    	btnAlarm.getStyleClass().addAll(Constants.CSS_BUTTON_ALARM);

		if(reminder > 0L){
			btnAlarm.getStyleClass().addAll(Constants.CSS_BUTTON_ALARM_SET);
    	}else{
    		btnAlarm.getStyleClass().addAll(Constants.CSS_BUTTON_ALARM_NOT_SET);
    	}  
    }
    
    /**This method set button priority style
     * **/
    private void setButtonPriorityStyle(String lvlString){
    	this.btnPriority.getStyleClass().removeAll(Constants.CSS_PRIORITY_LOW, Constants.CSS_PRIORITY_NORMAL, 
    											Constants.CSS_PRIORITY_CRITICAL, Constants.CSS_PRIORITY_DEFAULT);
    	
    	this.btnPriority.getStyleClass().addAll(Constants.CSS_BUTTON_PRIORITY);
    	switch (lvlString){
	    	case "1": //lowest
	    		this.btnPriority.getStyleClass().addAll(Constants.CSS_PRIORITY_LOW);
	    		break;
	    	case "2": //normal
	    		this.btnPriority.getStyleClass().addAll(Constants.CSS_PRIORITY_NORMAL);
	    		break;
	    	case "3": //highest
	    		this.btnPriority.getStyleClass().addAll(Constants.CSS_PRIORITY_CRITICAL);
	    		break;
	    		
	    	default: //either set nothing or error
	    		this.btnPriority.getStyleClass().addAll(Constants.CSS_PRIORITY_DEFAULT);
	    		break;
    	}
    }
    
    /**This method set button delete style
     * **/
    private void setButtonDeleteStyle(){
    	this.btnDelete.getStyleClass().addAll(Constants.CSS_BUTTON_DELETE); 	
    }
    
    /**This method set button edit style
     * **/
    private void setButtonEditStyle(){
    	this.btnEdit.getStyleClass().addAll(Constants.CSS_BUTTON_EDIT);
    }
    
    /**This method set label ID style
     * **/
    private void setLabelIDStyle(boolean isDone){
    	this.lblID.getStyleClass().removeAll(Constants.CSS_CELL_TEXT_IS_DONE, Constants.CSS_CELL_TEXT_STRIKE_THROUGH);
    	this.lblID.getStyleClass().addAll(Constants.CSS_CELL_ID);
    	this.lblID.setAlignment(Pos.CENTER);
    	if(isDone){
    		this.lblID.getStyleClass().addAll(Constants.CSS_CELL_TEXT_IS_DONE, Constants.CSS_CELL_TEXT_STRIKE_THROUGH);
    	}
    }
    
    /**This method set label title style
     * **/
    private void setLabelTitleStyle(boolean isDone) {
    	this.lblTitle.getStyleClass().removeAll(Constants.CSS_CELL_TEXT_IS_DONE, Constants.CSS_CELL_TEXT_STRIKE_THROUGH);
    	this.lblTitle.getStyleClass().add(Constants.CSS_CELL_TITLE);
    	this.lblTitle.setAlignment(Pos.CENTER_LEFT);
    	if(isDone){
    		this.lblTitle.getStyleClass().addAll(Constants.CSS_CELL_TEXT_IS_DONE, Constants.CSS_CELL_TEXT_STRIKE_THROUGH);
    	}
    }
    
    /**This method set label date time style
     * **/
    private void setLabelDateTimeStyle(boolean isDone) {
    	double maxWidth = 180.0;
    	this.lblDateTime.setMaxWidth(maxWidth);
    	this.lblDateTime.getStyleClass().removeAll(Constants.CSS_CELL_TEXT_STRIKE_THROUGH);
    	this.lblDateTime.getStyleClass().add(Constants.CSS_CELL_DATETIME);
        this.lblDateTime.setWrapText(true);
        if(isDone){
        	this.lblDateTime.getStyleClass().addAll(Constants.CSS_CELL_TEXT_STRIKE_THROUGH);
        }
    }
    
    /**This method set button is done style
     * **/
    private void setButtonIsDoneStyle(boolean isDone){
    	this.btnIsDone.getStyleClass().addAll(Constants.CSS_BUTTON_IS_DONE);
    	this.btnIsDone.getStyleClass().removeAll(Constants.CSS_BUTTON_IS_DONE_SET, Constants.CSS_BUTTON_IS_DONE_UNSET);
  
    	if(isDone){ //is done
    		this.btnIsDone.getStyleClass().addAll(Constants.CSS_BUTTON_IS_DONE_SET);
    	}else{
    		this.btnIsDone.getStyleClass().addAll(Constants.CSS_BUTTON_IS_DONE_UNSET);
    	}
    }
    
    /**
     * This method set button is done background
     * **/
    private void setButtonIsDoneBackground(int type){
    	this.btnIsDone.getStyleClass().removeAll(Constants.CSS_BUTTON_IS_DONE_BACKGROUND_YELLOW,
    									Constants.CSS_BUTTON_IS_DONE_BACKGROUND_GREEN, Constants.CSS_BUTTON_IS_DONE_BACKGROUND_RED);
    	if(type == 1){
    		this.btnIsDone.getStyleClass().addAll(Constants.CSS_BUTTON_IS_DONE_BACKGROUND_RED);
    	}
    	
    	if (type == -1 || type == 0){
    		this.btnIsDone.getStyleClass().addAll(Constants.CSS_BUTTON_IS_DONE_BACKGROUND_YELLOW);
    	}

    	if (type == 3){ //is done
    		this.btnIsDone.getStyleClass().addAll(Constants.CSS_BUTTON_IS_DONE_BACKGROUND_GREEN);
    	}
    }
    
    /**
     * This method add controls to VBox date time
     * **/
    private void addControlsToVBoxDateTime(){
    	this.vBoxDateTime.getChildren().add(this.lblDateTime);
    	this.vBoxDateTime.setAlignment(Pos.CENTER_RIGHT);
    }
    
    /**
     * This method add controls to VBox date time
     * **/
    private void addControlsToVBoxIsDone(){
    	this.vBoxButtonIsDone.getChildren().add(this.btnIsDone);
    	this.vBoxButtonIsDone.setAlignment(Pos.CENTER_LEFT);
    }
    
    /**
     * This method add controls to main grid
     * **/
    private void addControlsToGrid() {
    	//add(node, column index, row index)
    	this.grid.add(this.vBoxButtonIsDone, 0, 0);
    	GridPane.setMargin(this.vBoxButtonIsDone,new Insets(0, 0, 0, -5));
    	this.grid.add(lblID, 1, 0); 
    	this.grid.add(this.lblTitle, 2, 0);
    	this.grid.add(this.btnEdit, 3, 0);
    	this.grid.add(this.btnPriority, 4, 0);
        this.grid.add(this.btnAlarm, 5, 0);
        this.grid.add(this.vBoxDateTime, 6, 0);
        this.grid.add(this.btnDelete, 7, 0);
        GridPane.setMargin(this.btnDelete,new Insets(0, 5, 0, 0));
    }
    
    /**
     * This method set button tool tip
     * **/
    private void setButtonTooltip(Button btn, String tooltipMsg){
    	btn.setTooltip(new Tooltip(tooltipMsg));
    }
    
    /**
     * This method clear content in task cell
     * **/
    private void clearContent() {
        setText(null);
        setGraphic(null);
    }
 
    /**
     * This method add content to controls
     * **/
    private void addContent(Task mTask) {
    	String priorityToolTipMessage = "";
        String isDoneToolTipMessage = "";
        int currentTaskStatus = 0;
  
        this.clearContent();
        this.getID = String.valueOf(mTask.getID());
        this.getTitle = mTask.getTitle();
        this.getCategory = mTask.getCategory();
        this.getStartDate = mTask.getStartDate();
        this.getEndDate = mTask.getEndDate();
        this.getStartTime = mTask.getStartTime();
        this.getEndTime = mTask.getEndTime();
        this.getIsDone = mTask.getIsDone();
        this.getStartMillisecond = mTask.getStartMilliseconds();
        this.getEndMillisecond = mTask.getEndMilliseconds();
        this.getRemainder = mTask.getReminder();
        this.getPriority = mTask.getPriority();
        
        if(mTask.getTitle().length() > MAX_CHARACTER_IN_TITLE){
        	this.getTitle = this.getTitle.substring(0, MAX_CHARACTER_IN_TITLE) + "...";
        }
        
        this.lblTitle.setText(this.getTitle);
        this.lblID.setText(this.getID);
        this.btnIsDone.setUserData(this.getIsDone);

        if(this.getCategory.equals("timed")){
        	this.lblDateTime.setText(DISPLAY_START_DATE_TIME.replace("[datetime]", this.convertToFullDateString(this.getStartDate) + " " + this.getStartTime) + "\n" +
        							DISPLAY_END_DATE_TIME.replace("[datetime]", this.convertToFullDateString(this.getEndDate) + " " + this.getEndTime));
        	
        } else if(this.getCategory.equals("deadline")){
        	this.lblDateTime.setText(DISPLAY_END_DATE_TIME.replace("[datetime]", convertToFullDateString(this.getEndDate) + " " + this.getEndTime));
        	
        } else if(this.getCategory.equals("floating")){
        	this.lblDateTime.setText("");
        	
        }
        
        if(this.getIsDone){ //task is done or floating
        	setButtonIsDoneBackground(3); //green
        	isDoneToolTipMessage = "Task is done";
        }else{
    		if (this.getCategory.equals("floating")){ //if category == float
        		setButtonIsDoneBackground(4);	
        		isDoneToolTipMessage = "Click to mark as done";
            }else{
            	currentTaskStatus = TokenValidation.compareWithCurrentDate(this.getEndMillisecond, this.getRemainder);
            	setButtonIsDoneBackground(currentTaskStatus);
            	
            	if(currentTaskStatus == 1){ //red - overdue
            		isDoneToolTipMessage = "Overdue task\nClick to mark as done";	
            	}else{ //yellow - expiring soon
            		isDoneToolTipMessage = "Click to mark as done";	
            	}
            	
            }//end if

        }//end if
        
        this.btnIsDone.setTooltip(new Tooltip(isDoneToolTipMessage));
        
        
        setButtonIsDoneStyle(this.getIsDone);
        setLabelDateTimeStyle(this.getIsDone); //if is done, label will be strike out
        setLabelIDStyle(this.getIsDone); 
        setLabelTitleStyle(this.getIsDone); 
        setButtonPriorityStyle(this.getPriority); //set different color for different priority
        setButtonAlarmStyle(this.getRemainder, this.getIsDone); //set alarm icon - enable or disable
        setCellBackground(this.getIsDone); //if is done, background will be darker
        setGraphic(this.grid); //add grid to cell graphic
		
        
        //set btnAlarm tooltip - show reminder date and time
        String getAlarmDate = MainParser.convertMillisecondToDate(this.getRemainder);
        String getAlarmTime = MainParser.convertMillisecondToTime(this.getRemainder);
        if(getAlarmDate.equals("01/01/1970")){
        	getAlarmDate = "Alarm not set";
        	setButtonTooltip(this.btnAlarm, getAlarmDate);
        }else{
        	setButtonTooltip(this.btnAlarm, convertToFullDateString(getAlarmDate) + " " + getAlarmTime);
        }
        
        //set btnPriority tooltip - show priority (Critical, normal, low, or nothing)
        if(this.getPriority.equals("1")){
        	priorityToolTipMessage = "Low";
        }else if(this.getPriority.equals("2")){
        	priorityToolTipMessage = "Normal";
        }else if(this.getPriority.equals("3")){
        	priorityToolTipMessage = "Critical";
        }else{
        	priorityToolTipMessage = "Priority not set";
        }
        
        setButtonTooltip(btnPriority, priorityToolTipMessage);
        
    }
	
	/**Convert date into various type of date string
	 * Parameters:			rawDate - incoming date in format dd/mm/yyyy
	 * Returns:				String - date format in dd MMM yyyy or dd MMM
	 * **/
	private String convertToFullDateString(String rawDate){
		
		if(rawDate.equals("") || rawDate.isEmpty()){
			return "";
		}
		
		//convert from dd/MM/yyyy to dd MMM yyyy
	    SimpleDateFormat oldFormat = new SimpleDateFormat(Constants.DATETIME_FORMAT_STORAGE_2);// dd/MM/yyyy
        SimpleDateFormat newWithYearFormat = new SimpleDateFormat(Constants.DATETIME_FORMAT_FULL_SHORT); //dd MMM yyyy
        SimpleDateFormat newWithoutYearFormat2 = new SimpleDateFormat(Constants.DATETIME_FORMAT_FULL_SHORT_WITHOUT_YEAR); //dd MMM
        
        int rawYear = convertStringToInteger(rawDate.split("/")[2]);
        int nowYear = Calendar.getInstance().get(Calendar.YEAR);
        
        String newDate = "";
        try {
        	if(rawYear == nowYear){
        		newDate = newWithoutYearFormat2.format(oldFormat.parse(rawDate));
        	}else{
        		newDate = newWithYearFormat.format(oldFormat.parse(rawDate));
        	}
        	
			return newDate;
		} catch (ParseException e) {
			e.printStackTrace();
			return "-";
		}      
	}
	
	/**This method is the event handler for button is done
	 * **/
	EventHandler<MouseEvent> btnIsDoneEventHandler = new EventHandler<MouseEvent>() {
	    @Override
	    public void handle(MouseEvent event) {
	    	boolean isUpdated = false;
	    	boolean getCurrentStatus = false;
	    	
	    	String markCommandFormatString = "mark [id] -[type]";
	    	String markCommandEditedString = "";
	    	
	    	if(btnIsDone.getUserData() instanceof Boolean){
	    		getCurrentStatus = (boolean) btnIsDone.getUserData(); //get the current status of done 
	    	}
            
            if(!getCurrentStatus){ //if false
            	getIsDone = true; //change to true (done)
            	markCommandEditedString = markCommandFormatString.replace("[id]", getID).replace("[type]", Constants.PARSER_MARK_DONE);
            	
            }else{
            	getIsDone = false; //change to false (undone)
            	markCommandEditedString = markCommandFormatString.replace("[id]", getID).replace("[type]", Constants.PARSER_MARK_UNDONE);
            }
            
            isUpdated = mUIParent.executeCommand(markCommandEditedString);
            
            if(isUpdated){
            	setCellBackground(getIsDone);
            }     

	    }//end handle
	};
	
	/**This method is the event handler for button show alarm
	 * **/
	EventHandler<MouseEvent> btnShowAlarmEventHandler = new EventHandler<MouseEvent>(){
		@Override
		public void handle(MouseEvent event) {
			showAlarmPopOver(getRemainder);
		}
	};
	
	/**This method is the event handler for button show priority
	 * **/
	EventHandler<MouseEvent> btnShowPriorityEventHandler = new EventHandler<MouseEvent>(){
		@Override
		public void handle(MouseEvent event) {
			showPriorityPopOver(convertStringToInteger(getPriority));
		}	
	};
	
	/**This method is the event handler for button priority edit
	 * **/
	EventHandler<MouseEvent> btnPriorityEditEventHandler = new EventHandler<MouseEvent>(){
		@Override
		public void handle(MouseEvent event) {
        	showEditPopOver();
		}	
	};
	
	/**This method is the event handler for button delete
	 * **/
	EventHandler<MouseEvent> btnDeleteEventHandler = new EventHandler<MouseEvent>(){
		@Override
		public void handle(MouseEvent event) {
			String command = deleteCommand.replace("[id]", getID).trim(); //replace id by actual id	
			if(mUIParent != null){
				mUIParent.executeCommand(command); //execute delete command 
			}
		}	
	};
	
	/**This method show priority pop over with all the controls added
	 * **/
	private void showPriorityPopOver(int selectedPriorityLvl){
		if(this.mPopOverPriority != null){
			if(this.mPopOverPriority.isShowing()){
				this.mPopOverPriority.setAutoHide(true);
				return;
			}
		}
		
		String[] priorityCssArray = {Constants.CSS_POP_OVER_IMAGE_CRITICAL, Constants.CSS_POP_OVER_IMAGE_NORMAL, Constants.CSS_POP_OVER_IMAGE_LOW, Constants.CSS_POP_OVER_IMAGE_DEFAULT};
		String[] priorityArray = {"Critical", "Normal", "Low", "Default"};
		int[] priorityLvlArray = {3, 2, 1, 0};
		
		VBox vBox = new VBox();
		HBox hBox = new HBox();
		this.setPopOverMainHBoxStyle(hBox);
		
		this.lblPopOverTitle = new Label(Constants.UI_POP_OVER_PRIORITY_TITLE);
		this.lblPopOverPriorityMessage = new Label();
		Button btnPriorityChange = new Button("Change");
		
		setPopOverLabelMessageStyle(lblPopOverPriorityMessage, Constants.UI_POP_OVER_PRIORITY_WIDTH); //set message style
		setPopOverLabelTitle(lblPopOverTitle, Constants.UI_POP_OVER_PRIORITY_WIDTH);
		setPopOverButton(btnPriorityChange, Constants.UI_POP_OVER_PRIORITY_WIDTH, onPopOverBtnPriorityClick);
			
		vBox.getChildren().add(lblPopOverTitle); //Add title
		
		generatePriorityOptions(vBox, hBox, priorityArray, priorityLvlArray, priorityCssArray, selectedPriorityLvl);
		
		vBox.getChildren().add(btnPriorityChange); //add btn change
		VBox.setMargin(btnPriorityChange, new Insets(Constants.UI_POP_OVER_VBOX_MARGIN_TOP, 
														Constants.UI_POP_OVER_VBOX_MARGIN_RIGHT,
														Constants.UI_POP_OVER_VBOX_MARGIN_BOTTOM,
														Constants.UI_POP_OVER_VBOX_MARGIN_LEFT)); //set margin of btn change
		this.setPopOverMainVBoxStyle(vBox, Constants.UI_POP_OVER_PRIORITY_WIDTH, Constants.UI_POP_OVER_PRIORITY_HEIGHT);
		
		this.mPopOverPriority = new PopOver(vBox);
		this.mPopOverPriority.setHideOnEscape(true);
		this.mPopOverPriority.setArrowLocation(PopOver.ArrowLocation.RIGHT_TOP);
		this.mPopOverPriority.setAutoFix(true);
		this.mPopOverPriority.setAutoHide(true);
		this.mPopOverPriority.setDetachable(false);
		this.mPopOverPriority.show(btnPriority);  	
	}
	
	/**This method generate each priority levels in the parent horziontal box
	 * **/
	private void generatePriorityOptions(VBox grandParent, HBox parent, String[] priorityArray, int[] lvlArray, String[] cssArray, int selectedPriority){
		
		this.priorityGroup = new ToggleGroup();
		
		for(int i=0; i < priorityArray.length; i++){
			
			ImageView imgPriority = new ImageView();
			Label lblPriorityLevel = new Label(priorityArray[i]);
			RadioButton radioBtn = new RadioButton();
			
			setPopOverPriorityIconStyle(imgPriority, cssArray[i]);
			setPopOverPriorityLabelStyle(lblPriorityLevel, Constants.CSS_POP_OVER_LABEL_PRIORITY);
			
			radioBtn.setToggleGroup(this.priorityGroup);
			radioBtn.setUserData(lvlArray[i]);
			
			if(lvlArray[i] == selectedPriority){
				radioBtn.setSelected(true);
			}
			
			parent = new HBox(Constants.UI_POP_OVER_HBOX_SPACING);
			parent.getChildren().add(radioBtn);
			parent.getChildren().add(imgPriority);
			parent.getChildren().add(lblPriorityLevel);
			grandParent.getChildren().add(parent);
			
		}
	
	}
	
	/**This method set the icon style in pop over priority
	 * **/
	private void setPopOverPriorityIconStyle(ImageView iv, String cssClass){
		iv.setFitWidth(Constants.IMAGE_WIDTH);
		iv.setPreserveRatio(true);
		iv.setSmooth(true);
		iv.setCache(true);
		iv.getStyleClass().addAll(cssClass);
	}
	
	/**This method set the label style in pop over priority
	 * **/
	private void setPopOverPriorityLabelStyle(Label lbl, String cssClass){
		lbl.setAlignment(Pos.BASELINE_LEFT);
		lbl.getStyleClass().addAll(cssClass);
	}
	
	/**This method set the label message style in all pop over
	 * **/
	private void setPopOverLabelMessageStyle(Label lbl, double width){
		lbl.setTextAlignment(TextAlignment.CENTER);
		lbl.setAlignment(Pos.CENTER);
		lbl.setPrefWidth(width);
		lbl.setPrefHeight(Constants.LABEL_MESSAGE_HEIGHT);
		setPopOverLabelMessageVisible(lbl, false, false);
	}
	
	/**This method set the label message visibility
	 * **/
	private void setPopOverLabelMessageVisible(Label lbl, boolean isValid, boolean isVisible){
		lbl.getStyleClass().removeAll(Constants.CSS_POP_OVER_LABEL_CORRECT_MESSAGE, Constants.CSS_POP_OVER_LABEL_ERROR_MESSAGE);
		
		if(isVisible){
			if(isValid){ //valid, green background
				lbl.getStyleClass().addAll(Constants.CSS_POP_OVER_LABEL_CORRECT_MESSAGE);
				
			}else{//invalid, red background
				lbl.getStyleClass().addAll(Constants.CSS_POP_OVER_LABEL_ERROR_MESSAGE);	
			}
		}
		
		lbl.setVisible(isVisible);
	}
	
	/**This method set the label message text
	 * **/
	private void setPopOverLabelMessageText(Label lbl, String msg){
		lbl.setText(msg);
	}

	/**This method show pop over alarm with controls added
	 * Parameters: 		alarmValue - reminder value in long
	 * **/
	private void showAlarmPopOver(Long alarmValue){
	    /*
		 * ---------------------
		 * |       Alarm       |
		 * ---------------------
		 * |[=================]|
		 * |            <Enter>|
		 * |[   Message area  ]|
		 * 
		 * */
		if(this.mPopOverAlarm != null){
			if(this.mPopOverAlarm.isShowing()){
				this.mPopOverAlarm.setAutoHide(true);
				return;
			}
		}
		
		String getAlarmDate = MainParser.convertMillisecondToDate(alarmValue); //dd/MM/yyyy
		String getAlarmTime = MainParser.convertMillisecondToTime(alarmValue); //HH:mm
		
		String defaultDate = "01/01/1970";
		String defaultHour = "07";
		String defaultMin = "30";
		
		VBox vBox = new VBox();
		HBox hDateBox = new HBox(Constants.UI_POP_OVER_HBOX_SPACING);
		HBox hTimeBox = new HBox(Constants.UI_POP_OVER_HBOX_SPACING);
		this.setPopOverMainHBoxStyle(hDateBox);
		this.setPopOverMainHBoxStyle(hTimeBox);
		
		this.lblPopOverTitle = new Label(Constants.UI_POP_OVER_ALARM_TITLE);
		this.lblPopOverAlarmMessage = new Label();
		this.lblPopOverTimeTip = new Label(Constants.UI_POP_OVER_COLON);
		this.lblPopOverDateTitle = new Label(Constants.UI_POP_OVER_DATE_TITLE);
		this.lblPopOverTimeTitle = new Label(Constants.UI_POP_OVER_TIME_TITLE);
		this.lblPopOverColon = new Label(Constants.UI_POP_OVER_COLON);
		this.txtPopOverAlarmHourField = new TextField();
		this.txtPopOverAlarmMinField = new TextField();
		
		Button btnAlarmChange = new Button(Constants.UI_POP_OVER_ALARM_BUTTON_CHANGE_TITLE);

		this.datePickerPopOverAlarm = new DatePicker(); 
		this.datePickerPopOverAlarm.setPromptText(Constants.UI_POP_OVER_DATEPICKER_PROMPT_TEXT);
		
		if(!getAlarmDate.equals(defaultDate)){
			this.datePickerPopOverAlarm.setValue(convertStringToLocalDate(getAlarmDate)); //set year, month, day to datepicker
		}
		
		this.datePickerPopOverAlarm.setConverter(datePickerStringConverter);

		setPopOverLabelTitle(this.lblPopOverTitle, Constants.UI_POP_OVER_ALARM_WIDTH);
		setPopOverLabelDateTime(this.lblPopOverDateTitle, this.lblPopOverTimeTitle, 50.0);
		setPopOverTextFieldHourMinute(this.txtPopOverAlarmHourField, this.txtPopOverAlarmMinField);
		setPopOverLabelTimeTip(this.lblPopOverTimeTip);
		setPopOverLabelMessageStyle(this.lblPopOverAlarmMessage, Constants.UI_POP_OVER_ALARM_WIDTH); //set message style
		setPopOverButton(btnAlarmChange, Constants.UI_POP_OVER_ALARM_WIDTH, onPopOverBtnAlarmClick);
		
		if(!(getAlarmDate.equals(defaultDate) && getAlarmTime.split(":")[0].equals(defaultHour) && getAlarmTime.split(":")[1].equals(defaultMin))){
			this.txtPopOverAlarmHourField.setText(getAlarmTime.split(":")[0]); // Hour
			this.txtPopOverAlarmMinField.setText(getAlarmTime.split(":")[1]); // Minute
		}

				
		hDateBox.getChildren().add(this.lblPopOverDateTitle); //Datee:
		hDateBox.getChildren().add(this.datePickerPopOverAlarm); // datepicker
		hTimeBox.getChildren().add(this.lblPopOverTimeTitle); //Time:
		hTimeBox.getChildren().add(this.txtPopOverAlarmHourField); //hour
		hTimeBox.getChildren().add(this.lblPopOverColon); // :
		hTimeBox.getChildren().add(this.txtPopOverAlarmMinField); //min
		hTimeBox.getChildren().add(this.lblPopOverTimeTip); //time tip
		HBox.setMargin(this.lblPopOverTimeTip, new Insets(Constants.UI_POP_OVER_HBOX_MARGIN_TOP, 
															Constants.UI_POP_OVER_HBOX_MARGIN_RIGHT,
															Constants.UI_POP_OVER_HBOX_MARGIN_BOTTOM, 
															Constants.UI_POP_OVER_HBOX_MARGIN_LEFT));
		VBox.setMargin(btnAlarmChange, new Insets(Constants.UI_POP_OVER_VBOX_MARGIN_TOP, 
													Constants.UI_POP_OVER_VBOX_MARGIN_RIGHT,
													Constants.UI_POP_OVER_VBOX_MARGIN_BOTTOM, 
													Constants.UI_POP_OVER_VBOX_MARGIN_LEFT));
		vBox.getChildren().add(this.lblPopOverTitle);
		vBox.getChildren().add(hDateBox);
		vBox.getChildren().add(hTimeBox);
		vBox.getChildren().add(btnAlarmChange);
		vBox.getChildren().add(this.lblPopOverAlarmMessage);
		this.setPopOverMainVBoxStyle(vBox, Constants.UI_POP_OVER_ALARM_WIDTH, Constants.UI_POP_OVER_ALARM_HEIGHT);
		
		this.mPopOverAlarm = new PopOver(vBox);
		this.mPopOverAlarm.setHideOnEscape(true);
		this.mPopOverAlarm.setArrowLocation(PopOver.ArrowLocation.RIGHT_TOP);
		this.mPopOverAlarm.setAutoFix(true);
		this.mPopOverAlarm.setAutoHide(true);
		this.mPopOverAlarm.setDetachable(false);
    	this.mPopOverAlarm.show(this.btnAlarm); 
	}
	
	//================== POP OVER EDIT TASK ========================
	private void showEditPopOver(){
		String defaultTime = Constants.UI_POP_OVER_DEFAULT_HOUR + Constants.UI_POP_OVER_COLON + Constants.UI_POP_OVER_DEFAULT_MINUTE;
		
		if(this.mPopOverEdit != null){
			if(this.mPopOverEdit.isShowing()){
				this.mPopOverEdit.setAutoHide(true);
				return;
			}
		}
		
		this.lblPopOverTitle = new Label(Constants.UI_POP_OVER_EDIT_TITLE);
		this.txtAreaPopOverEditTaskTitle = new TextArea();
		this.lblPopOverDateTitle = new Label(Constants.UI_POP_OVER_START_DATE_TITLE);
		this.lblPopOverTimeTitle = new Label(Constants.UI_POP_OVER_START_TIME_TITLE);
		this.lblPopOverColon = new Label(Constants.UI_POP_OVER_COLON);
		this.lblPopOverTimeTip = new Label(Constants.UI_POP_OVER_TIME_TIP);
		this.txtPopOverEditStartHourField = new TextField(); //start hour
		this.txtPopOverEditStartMinField = new TextField(); //start minute
		this.datePickerPopOverEditStartDate = new DatePicker(); //start datae
		this.txtPopOverEditEndHourField = new TextField(); //end hour
		this.txtPopOverEditEndMinField = new TextField(); //end min
		this.datePickerPopOverEditEndDate = new DatePicker(); //end date
		this.lblPopOverEditMessage = new Label(); //message 
	
		Button btnEdit = new Button(Constants.UI_POP_OVER_EDIT_BUTTON_CHANGE_TITLE);	
		VBox vBox = new VBox();
		HBox hBox = new HBox();
		this.setPopOverMainHBoxStyle(hBox);
		
		//Set Contents
		this.txtAreaPopOverEditTaskTitle.setPromptText("Type in a new task title");
		this.txtAreaPopOverEditTaskTitle.setText(this.getTitle);
		this.datePickerPopOverEditStartDate.setPromptText("01 January 2015");
		this.datePickerPopOverEditStartDate.setConverter(datePickerStringConverter);
		this.datePickerPopOverEditEndDate.setPromptText("22 January 2015");
		this.datePickerPopOverEditEndDate.setConverter(datePickerStringConverter);
		
		
		if(!(this.getStartDate == null || this.getStartDate.equals("") && this.getStartDate.isEmpty() || 
				this.getStartDate.equals(Constants.UI_POP_OVER_DEFAULT_DATE) && this.getStartTime.equals(defaultTime))){ //not default date time

			this.datePickerPopOverEditStartDate.setValue(convertStringToLocalDate(this.getStartDate)); //set year, month, day to datepicker		
			this.txtPopOverEditStartHourField.setText(this.getStartTime.split(":")[0]);
			this.txtPopOverEditStartMinField.setText(this.getStartTime.split(":")[1]);
		}
		
		if(!(this.getEndDate == null || this.getEndDate.equals("") && this.getEndDate.isEmpty() ||
				this.getEndDate.equals(Constants.UI_POP_OVER_DEFAULT_DATE) && this.getEndTime.equals(defaultTime))){ //not default date time
			
			this.datePickerPopOverEditEndDate.setValue(convertStringToLocalDate(this.getEndDate)); //set year, month, day to datepicker
			this.txtPopOverEditEndHourField.setText(this.getEndTime.split(":")[0]);
			this.txtPopOverEditEndMinField.setText(this.getEndTime.split(":")[1]);
		}

		setPopOverLabelTitle(this.lblPopOverTitle, Constants.UI_POP_OVER_EDIT_WIDTH); //style the label title 
		setPopOverLabelDateTime(this.lblPopOverDateTitle, this.lblPopOverTimeTitle, Constants.UI_POP_OVER_LABEL_DATETIME_WIDTH); //style the labels 
		setPopOverTextFieldHourMinute(this.txtPopOverEditStartHourField, this.txtPopOverEditStartMinField);
		setPopOverLabelTimeTip(this.lblPopOverTimeTip);
		setPopOverButton(btnEdit, Constants.UI_POP_OVER_EDIT_WIDTH, this.onPopOverBtnEditClick);	 //style the button edit 
		setPopOverLabelMessageStyle(this.lblPopOverEditMessage, Constants.UI_POP_OVER_EDIT_WIDTH); //set message style
		
		this.txtAreaPopOverEditTaskTitle.getStyleClass().addAll(Constants.CSS_POP_OVER_TEXTAREA_EDIT);
		this.txtAreaPopOverEditTaskTitle.setPrefRowCount(3); //text area
		this.txtAreaPopOverEditTaskTitle.setPrefWidth(Constants.UI_POP_OVER_EDIT_WIDTH);
		this.txtAreaPopOverEditTaskTitle.setWrapText(true);
		
		vBox.getChildren().add(lblPopOverTitle); //add title
		vBox.getChildren().add(txtAreaPopOverEditTaskTitle); //add task title
			
		hBox = new HBox(); //start date
		this.setPopOverMainHBoxStyle(hBox);
		hBox.getChildren().add(this.lblPopOverDateTitle); 
		hBox.getChildren().add(this.datePickerPopOverEditStartDate);
		vBox.getChildren().add(hBox);
		
		hBox = new HBox(); //start hour and minute
		this.setPopOverMainHBoxStyle(hBox);
		hBox.getChildren().add(this.lblPopOverTimeTitle);  
		hBox.getChildren().add(this.txtPopOverEditStartHourField);
		hBox.getChildren().add(lblPopOverColon);
		hBox.getChildren().add(this.txtPopOverEditStartMinField);
		hBox.getChildren().add(this.lblPopOverTimeTip);
		HBox.setMargin(this.lblPopOverTimeTip, new Insets(10,0,0,0));
		vBox.getChildren().add(hBox);
		
		this.lblPopOverDateTitle = new Label(Constants.UI_POP_OVER_END_DATE_TITLE);
		this.lblPopOverTimeTitle = new Label(Constants.UI_POP_OVER_END_TIME_TITLE);
		this.lblPopOverColon = new Label(Constants.UI_POP_OVER_COLON);
		this.lblPopOverTimeTip = new Label(Constants.UI_POP_OVER_TIME_TIP);
		
		setPopOverLabelDateTime(this.lblPopOverDateTitle, this.lblPopOverTimeTitle, 80.0); //style the labels again
		setPopOverTextFieldHourMinute(this.txtPopOverEditEndHourField, this.txtPopOverEditEndMinField);
		setPopOverLabelTimeTip(this.lblPopOverTimeTip);
		
		hBox = new HBox(); //end date
		this.setPopOverMainHBoxStyle(hBox);
		hBox.getChildren().add(this.lblPopOverDateTitle); 
		hBox.getChildren().add(this.datePickerPopOverEditEndDate);
		vBox.getChildren().add(hBox);
		
		hBox = new HBox(); //end hour and minute
		this.setPopOverMainHBoxStyle(hBox);
		hBox.getChildren().add(this.lblPopOverTimeTitle);  
		hBox.getChildren().add(this.txtPopOverEditEndHourField);
		hBox.getChildren().add(this.lblPopOverColon);
		hBox.getChildren().add(this.txtPopOverEditEndMinField);
		hBox.getChildren().add(this.lblPopOverTimeTip);
		HBox.setMargin(this.lblPopOverTimeTip, new Insets(Constants.UI_POP_OVER_HBOX_MARGIN_TOP,
														Constants.UI_POP_OVER_HBOX_MARGIN_RIGHT,
														Constants.UI_POP_OVER_HBOX_MARGIN_BOTTOM,
														Constants.UI_POP_OVER_HBOX_MARGIN_LEFT));
		
		this.setPopOverMainVBoxStyle(vBox, Constants.UI_POP_OVER_EDIT_WIDTH, Constants.UI_POP_OVER_EDIT_HEIGHT);
		vBox.getChildren().add(hBox);
		vBox.getChildren().add(btnEdit); //add edit button
		VBox.setMargin(btnEdit, new Insets(Constants.UI_POP_OVER_VBOX_MARGIN_TOP,
											Constants.UI_POP_OVER_VBOX_MARGIN_RIGHT,
											Constants.UI_POP_OVER_VBOX_MARGIN_BOTTOM,
											Constants.UI_POP_OVER_VBOX_MARGIN_LEFT));
		vBox.getChildren().add(this.lblPopOverEditMessage); //add message
		
		this.mPopOverEdit = new PopOver(vBox);
		this.mPopOverEdit.setHideOnEscape(true);
		this.mPopOverEdit.setArrowLocation(PopOver.ArrowLocation.RIGHT_TOP);
		this.mPopOverEdit.setAutoFix(true);
		this.mPopOverEdit.setAutoHide(true);
		this.mPopOverEdit.setDetachable(false);
    	this.mPopOverEdit.show(this.btnEdit);
		
	}
	
	/**This method set the horizontal box style
	 * **/
	private void setPopOverMainHBoxStyle(HBox hBox){
		hBox.setSpacing(Constants.UI_POP_OVER_HBOX_SPACING);
	}
	
	/**This method set the vertical box style
	 * **/
	private void setPopOverMainVBoxStyle(VBox vBox, double width, double height){
		vBox.setSpacing(Constants.UI_POP_OVER_VBOX_SPACING);
		vBox.setPadding(new Insets(Constants.UI_POP_OVER_VBOX_PADDING_INSETS_TOP,
				Constants.UI_POP_OVER_VBOX_PADDING_INSETS_RIGHT,
				Constants.UI_POP_OVER_VBOX_PADDING_INSETS_BOTTOM,
				Constants.UI_POP_OVER_VBOX_PADDING_INSETS_LEFT));
		
		vBox.getStyleClass().addAll(Constants.CSS_POP_OVER_CONTENT_AREA); //set style
	}
	
	/**DatePicker string converter that override toString and fromString.
	 * Used for formatting date
	 * **/
	private StringConverter<LocalDate> datePickerStringConverter = new StringConverter<LocalDate>() {
		DateTimeFormatter dateFormatter = DateTimeFormatter.ofPattern(Constants.DATETIME_FORMAT_DATEPICKER); //e.g. 18 January 2015

		@Override 
		public String toString(LocalDate date) {
			if (date != null) {
				return dateFormatter.format(date);
			} else {
				return "";
			}
		}

		@Override 
		public LocalDate fromString(String string) {
			if (string != null && !string.isEmpty()) {
				return LocalDate.parse(string, dateFormatter);
			} else {
				return null;
			}
		}
	};
	
	/**This method style the pop over label title
	 * Parameters: 		lbl - the label of each pop over
	 * 					width - the desired width for the title
	 * **/
	private void setPopOverLabelTitle(Label lbl, double width){
		lbl.getStyleClass().addAll(Constants.CSS_POP_OVER_TITLE);
		lbl.setPrefWidth(width);
		lbl.setTextAlignment(TextAlignment.CENTER);
		lbl.setAlignment(Pos.CENTER);
	}
	
	/**This method style the pop over label date and time
	 * Parameters: 		lblDate - the date label of each pop over
	 * 					lblTime - the time label for each pop over
	 * 					width - the desired width for the both date and time
	 * **/
	private void setPopOverLabelDateTime(Label lblDate, Label lblTime, double width){
		lblDate.setPrefWidth(width);
		lblDate.setAlignment(Pos.CENTER_RIGHT);
		lblTime.setPrefWidth(width);
		lblTime.setAlignment(Pos.CENTER_RIGHT);
	}
	
	/**This method style the pop over label title
	 * Parameters: 		lbl - the label of each pop over
	 * 					width - the desired width for the title
	 * **/
	private void setPopOverTextFieldHourMinute(TextField txtHr, TextField txtMin){
		txtHr.setPrefWidth(Constants.UI_POP_OVER_TEXT_HOUR_WIDTH);
		txtHr.setPromptText(Constants.UI_POP_OVER_TEXT_HOUR_PROMPT_TEXT);
		txtMin.setPrefWidth(Constants.UI_POP_OVER_TEXT_MINUTE_WIDTH);
		txtMin.setPromptText(Constants.UI_POP_OVER_TEXT_MINUTE_PROMPT_TEXT);
	}
	
	/**This method style the pop over label time
	 * Parameters: 		lbl - the label time of each pop over
	 * **/
	private void setPopOverLabelTimeTip(Label lbl){
		lbl.getStyleClass().addAll(Constants.CSS_POP_OVER_TIME_TIP); //set tip style (after the minute input)
	}
	
	/**This method style the pop over label button
	 * Parameters: 		btn - the button of each pop over
	 * 					width - the desired width for the title
	 * 					event - action event for the button
	 * **/
	private void setPopOverButton(Button btn, double width, EventHandler<ActionEvent> event){
		btn.setPrefWidth(width);
		btn.getStyleClass().addAll(Constants.CSS_POP_OVER_BUTTON_CHANGE);
		btn.addEventFilter(ActionEvent.ACTION, event);
	}
	
	/**Event handler for button edit
	 * **/
	private EventHandler<ActionEvent> onPopOverBtnEditClick = new EventHandler<ActionEvent>() { //
		@Override
        public void handle(ActionEvent event) {
			boolean isEdited = false;
			boolean isStartDateTimeEmpty = false;
			boolean isEndDateTimeEmpty = false;
			
			LocalDate rawStartDate = datePickerPopOverEditStartDate.getValue();
			LocalDate rawEndDate = datePickerPopOverEditEndDate.getValue();
			
			String newTitle = txtAreaPopOverEditTaskTitle.getText(); //new title
			String newStartDate = convertDateToStorageFormat(rawStartDate); //new start date
			String newEndDate = convertDateToStorageFormat(rawEndDate); //new end date
			String newStartHour = txtPopOverEditStartHourField.getText(); //new start hour
			String newStartMinute = txtPopOverEditStartMinField.getText(); //new start minute
			String newEndHour = txtPopOverEditEndHourField.getText(); //new end hour
			String newEndMinute = txtPopOverEditEndMinField.getText(); //new end minute
			
			String newStartTime = "";
			String newEndTime = "";
			String command = editTaskcommand;
			
			if(!isTitleValid(newTitle)){ //check title
				setPopOverLabelMessageVisible(lblPopOverEditMessage, false, true); //show error message
    			setPopOverLabelMessageText(lblPopOverEditMessage, Constants.CELL_POP_OVER_INVALID_EDIT_TITLE_MESSAGE);
    			return;
			}
			
			if(!(isValidHour(newStartHour) && isValidMinute(newStartMinute))){ //check is valid for start hour and minute (accept empty)
				setPopOverLabelMessageVisible(lblPopOverEditMessage, false, true); //show error message
    			setPopOverLabelMessageText(lblPopOverEditMessage, Constants.CELL_POP_OVER_INVALID_EDIT_START_TIME_MESSAGE);
    			return;
			}
			
			if(!(isValidHour(newEndHour) && isValidMinute(newEndMinute))){ //check is valid for end hour and minute (accept empty)
				setPopOverLabelMessageVisible(lblPopOverEditMessage, false, true); //show error message
    			setPopOverLabelMessageText(lblPopOverEditMessage, Constants.CELL_POP_OVER_INVALID_EDIT_END_TIME_MESSAGE);
    			return;
			}
			
			
			//Check both start date and time
			if((newStartDate.equals("") || newStartDate.isEmpty()) && 
					(newStartHour.equals("") || newStartHour.isEmpty()) && 
					(newStartMinute.equals("") || newStartMinute.isEmpty())){
				//start date, time is empty
				//remove start date and time
				isStartDateTimeEmpty = true;
					
			}else if(!(newStartDate.equals("") || newStartDate.isEmpty()) && 
					((newStartHour.equals("") || newStartHour.isEmpty()) ||
					(newStartMinute.equals("") || newStartMinute.isEmpty()))) { //date is not empty, but hour or minute is empty
				
				setPopOverLabelMessageVisible(lblPopOverEditMessage, false, true); //show error message
    			setPopOverLabelMessageText(lblPopOverEditMessage, Constants.CELL_POP_OVER_INVALID_EDIT_START_TIME_MESSAGE);
    			return;
    			
			}else{	
				newStartTime = newStartHour + ":" + newStartMinute;
				isStartDateTimeEmpty = false;	
			}
			
			//Check both end date and time
			if((newEndDate.equals("") || newEndDate.isEmpty()) && 
					(newEndHour.equals("") || newEndHour.isEmpty()) && 
					(newEndMinute.equals("") || newEndMinute.isEmpty())){
				
				isEndDateTimeEmpty = true;
				
			}else if(!(newStartDate.equals("") || newStartDate.isEmpty()) && 
					((newEndHour.equals("") || newEndHour.isEmpty()) ||
					(newEndMinute.equals("") || newEndMinute.isEmpty()))) { //date is not empty, but hour or minute is empty

				setPopOverLabelMessageVisible(lblPopOverEditMessage, false, true); //show error message
    			setPopOverLabelMessageText(lblPopOverEditMessage, Constants.CELL_POP_OVER_INVALID_EDIT_END_TIME_MESSAGE);
    			return;
    			
			}else{
				newEndTime = newEndHour + ":" + newEndMinute;
				isEndDateTimeEmpty = false;
			}
			
			if(isStartDateTimeEmpty && isEndDateTimeEmpty){ //anything to float
				command = command.replace("-[new_start_date]", "").replace("-[new_start_time]", "");
				command = command.replace("-[new_end_date]", "").replace("-[new_end_time]", "");

			}else if (isStartDateTimeEmpty && !isEndDateTimeEmpty){ //timed to deadline
				command = command.replace("[new_start_date]", newEndDate).replace("[new_start_time]", newEndTime);
				command = command.replace("-[new_end_date]", "").replace("-[new_end_time]", "");
				
			}else if (!isStartDateTimeEmpty && isEndDateTimeEmpty){ //timed to deadline
				command = command.replace("[new_start_date]", newStartDate).replace("[new_start_time]", newStartTime);
				command = command.replace("-[new_end_date]", "").replace("-[new_end_time]", "");
				
			}else{
				command = command.replace("[new_start_date]", newStartDate).replace("[new_start_time]", newStartTime);
				command = command.replace("[new_end_date]", newEndDate).replace("[new_end_time]", newEndTime);
			}
			
			command = command.replace("[id]", getID);
			command = command.replace("[new_title]", newTitle);
			
			isEdited = mUIParent.executeCommand(command);
			if(isEdited){
				setPopOverLabelMessageVisible(lblPopOverEditMessage, true, true); //show success message
    			setPopOverLabelMessageText(lblPopOverEditMessage, Constants.CELL_POP_OVER_SUCCESS_EDIT_MESSAGE);
			}else{
				setPopOverLabelMessageVisible(lblPopOverEditMessage, false, true); //show error message
    			setPopOverLabelMessageText(lblPopOverEditMessage, Constants.CELL_POP_OVER_FAIL_EDIT_MESSAGE);
			}
			
			closePopOverEdit();
			//edit [id] -[new_title] -[new_start_date] -[new_start_time] -[new_end_date] -[new_end_time]";
			
		}
	};
	
	/**Event handler for pop over button priority change
	 * **/
	private EventHandler<ActionEvent> onPopOverBtnPriorityClick = new EventHandler<ActionEvent>() {
        @Override
        public void handle(ActionEvent event) {
        	if(priorityGroup != null){
        		//priority command e.g. = priority id- 0/1/2/3
        		String newLevel = priorityGroup.getSelectedToggle().getUserData().toString();
        		String priorityCommand = editPriorityCommand.replace("[id]", getID).replace("[level]", newLevel);
        		boolean hasChanged = false;
        		
        		//Execute command
        		if(mUIParent != null){
        			hasChanged = mUIParent.executeCommand(priorityCommand);
        		}
        		
        		if(hasChanged){
        			setPopOverLabelMessageVisible(lblPopOverPriorityMessage, true, true); //show success message
        			setPopOverLabelMessageText(lblPopOverPriorityMessage, Constants.CELL_POP_OVER_SUCCESS_PRIORITY_MESSAGE);
        		}else{
        			setPopOverLabelMessageVisible(lblPopOverPriorityMessage, false, true); //show error message
        			setPopOverLabelMessageText(lblPopOverPriorityMessage, Constants.CELL_POP_OVER_FAIL_PRIORITY_MESSAGE);
        		}
        		
        		closePopOverPriority();
        	}
        }
    };
    
    /**Event handler for pop over button alarm change
	 * **/
    private EventHandler<ActionEvent> onPopOverBtnAlarmClick = new EventHandler<ActionEvent>() {
        @Override
        public void handle(ActionEvent event) {
        	if(datePickerPopOverAlarm != null && txtPopOverAlarmHourField != null && txtPopOverAlarmMinField != null){
        		LocalDate date = datePickerPopOverAlarm.getValue();
        		
        		//edit alarm command = remind id -sd -st
        		//off alarm command  = remind id -off
        		String newDate = convertDateToStorageFormat(date);
        		String newHour = txtPopOverAlarmHourField.getText();
        		String newMinute = txtPopOverAlarmMinField.getText();
        		String alarmCommand = "";
        		boolean hasChanged = false;
        		
        		if(!(isValidHour(newHour) && isValidMinute(newMinute))){ //check is valid for hour and minute
        			setPopOverLabelMessageVisible(lblPopOverAlarmMessage, false, true); //show error message
        			setPopOverLabelMessageText(lblPopOverAlarmMessage, Constants.CELL_POP_OVER_INVALID_ALARM_TIME_MESSAGE);
        			return;
        		}
        		
        		if(!(newDate.isEmpty() || newDate.equals("") 
        				|| newDate.isEmpty() || newHour.equals("") 
        				|| newMinute.isEmpty() || newMinute.equals(""))){
        			alarmCommand = editAlarmCommand.replace("[id]", getID).replace("[start_date]", newDate)
        											.replace("[start_time]", addLeadingZero(convertTimeEmptyToValue(newHour)) + ":" + 
        																		addLeadingZero(convertTimeEmptyToValue(newMinute)));
        		}else{
        			//date is empty, time is empty
        			//means off
        			alarmCommand = offAlarmCommand.replace("[id]", getID);
        		}
        		
        		//Execute command
        		if(mUIParent != null){
        			hasChanged = mUIParent.executeCommand(alarmCommand);
        		}
        		
        		if(hasChanged){
	        		setPopOverLabelMessageVisible(lblPopOverAlarmMessage, true, true); //show success message
	    			setPopOverLabelMessageText(lblPopOverAlarmMessage, Constants.CELL_POP_OVER_SUCCESS_ALARM_MESSAGE);
        		}else{
	    			setPopOverLabelMessageVisible(lblPopOverAlarmMessage, false, true); //show error message
	    			setPopOverLabelMessageText(lblPopOverAlarmMessage, Constants.CELL_POP_OVER_FAIL_ALARM_MESSAGE);
        		}
        		
        		closePopOverAlarm();
    			        		
        	}
        	
        }
    };
    
    /**This method validate title
     * Parameters:		title - string title
     * Returns:			boolean - true or false
   	 * **/
    private boolean isTitleValid(String title){
		if(title.isEmpty() || title.equals("")){ //don't accept empty
			return false;
		}
		return true;
	}
    
    /**This method validate hour 
     * Parameters:		hour - string hour
     * Returns:			boolean - true or false
   	 * **/
    private boolean isValidHour(String hour){
    	//accept empty, means 0
    	try{
    		if(convertStringToInteger(hour) < 0 || convertStringToInteger(hour) > 23){
        		return false;
        	}
    	}catch(NumberFormatException e){ //maybe hour contain alphabet
    		e.printStackTrace();
    		return false;
    	}
    	return true;
    }
    
    /**This method validate minute
     * Parameters:		minute - string minute
     * Returns:			boolean - true or false
   	 * **/
    private boolean isValidMinute(String minute){
    	//accept empty, means 0
    	try{
    		if(convertStringToInteger(minute) < 0 || convertStringToInteger(minute) > 60){
        		return false;
        	}
    	}catch(NumberFormatException e){ //maybe hour contain alphabet
    		e.printStackTrace();
    		return false;
    	}
    	return true;
    }
    
    /**This method convert a date string to a valid date format
     * Parameters:		rawDate - in the format dd/MM/yyyy
     * Returns:			LocalDate - valid date of the raw date
   	 * **/
    private LocalDate convertStringToLocalDate(String rawDate){ //rawDate in format dd/mm/yyyy
    	return LocalDate.of(convertStringToInteger(rawDate.split("/")[2]), 
							convertStringToInteger(rawDate.split("/")[1]), 
							convertStringToInteger(rawDate.split("/")[0]));
    }
    
    /**This method convert date to a valid storage date format
     * Parameters:		rawDate - in the format dd/MM/yyyy
     * Returns:			String - date in storage format d/M/yyyy
   	 * **/
    private String convertDateToStorageFormat(LocalDate rawDate){
		DateTimeFormatter dateFormatter = DateTimeFormatter.ofPattern(Constants.DATETIME_FORMAT_STORAGE); //e.g. 18/4/2015
		
		if(rawDate == null){
			return "";
		}
		
		return dateFormatter.format(rawDate);
    }
    
    /**This method convert a empty time to zeros if there's any
     * Parameters:		time - String time
     * Returns:			String - either 00 or the same
   	 * **/
    private String convertTimeEmptyToValue(String time){
    	if(time.isEmpty() || time.equals("")){
    		return "00";
    	}
    	return time;
    }
    
	private int convertStringToInteger(String s){
		if(s.equals("") || s.isEmpty()){
			return 0;
		}
		return Integer.parseInt(s);
	}
	
	private String addLeadingZero(String str){
		if(str.length() == 1){
			return "0" + str;
		}
		return str;
	}

	
}

	// End of segment: D:\install location\java\work\CS2103 PISTA\src\pista\ui\TaskListCell.java





	/**
	 * origin: D:\install location\java\work\CS2103 PISTA\src\pista\ui\UIController.java
	 */

	@FXML
	void onUIKeyPressed(KeyEvent event) { // UI listen key press
		if (Constants.KEY_COMBINATION_HELP.match(event)){ //when pressed F1, show help
			showHelp();
		}

		if (Constants.KEY_COMBINATION_START_GUIDE.match(event)){ //when pressed F2, show start guide
			initStartGuide();
		}	
	}

	// End of segment: D:\install location\java\work\CS2103 PISTA\src\pista\ui\UIController.java





	/**
	 * origin: D:\install location\java\work\CS2103 PISTA\src\pista\ui\UIController.java
	 */

	@FXML
	public void initialize() {
		String logicOutput = "";
		
		this.initTimeClock();
		this.initReminder();
		this.initMainParser();
		this.initStorage();
		this.initLogic();
		this.initPreferences(); //initialize preferences
		this.initLogging(); //initialize logging
		this.initButtonRedo();
		this.initButtonUndo();
		this.initButtonSetting(); 
		this.initButtonAddNewTask();
		this.initButtonHelp();
		this.initButtonRefresh();

		this.addControlsToTopArea(); //add controls to the top anchor top area
		
		this.mLogic.initLogging(); //initialize Logic logging
		this.mLogic.initStorage(); //initialize Logic storage
		this.mLogic.initPreference(); //initialize Logic preference
		
		if(this.getPreferencePistaFlag() == Constants.PREFERENCE_FIRST_LAUNCH_VALUE){ //equals 0
			this.initStartGuide(); //start the start guide
			this.setPreferencePistaFlag(Constants.PREFERENCE_SUBSQUENT_LAUNCH_VALUE); //update the preference of the flag = 1
			this.setPreferenceFilePath(this.getNewLaunchFileLocation()); //set preference file location to new file path
			this.mLogic.writeNewFile(this.getNewLaunchFileLocation()); //write default XML string to new file
		}		

		this.mStorage.setDataFileLocation(getPreferenceFilePath());
		this.mStorage.initLogging(); //initialize Storage logging
		
		this.anchorPaneMain.getStyleClass().addAll(Constants.UI_CSS_TRANSPARENT_BACKGROUND);
		this.txtBoxCommand.getStyleClass().addAll(Constants.UI_CSS_TEXT_BOX);
		this.btnEnter.getStyleClass().addAll(Constants.UI_CSS_BUTTON);
		this.txtStatus.getStyleClass().addAll(Constants.UI_CSS_TEXT_BACKGROUND, Constants.UI_CSS_TEXT_STATUS);
		this.txtStatus.setText(logicOutput);

		this.txtBoxCommand.addEventHandler(KeyEvent.KEY_RELEASED, new EventHandler<KeyEvent>(){
			@Override
			public void handle(KeyEvent event){
				if (Constants.KEY_COMBINATION_AUTO_COMPLETE.match(event)){
					onCtrlSpacePressed();

				}else if (Constants.KEY_COMBINATION_UP.match(event)) {
					onUpPressed();

				}else if (Constants.KEY_COMBINATION_DOWN.match(event)) {
					onDownPressed();
				}
			}
		});

		logicOutput = mLogic.load();
		
		if(logicOutput.equals(Constants.LOGIC_SUCCESS_LOAD_XML)){
			initTaskListInListView(); //initialize listview
		}

	}//end initialize

	// End of segment: D:\install location\java\work\CS2103 PISTA\src\pista\ui\UIController.java





	/**
	 * origin: D:\install location\java\work\CS2103 PISTA\src\pista\ui\UIController.java
	 */

	@FXML
	public void enter() throws IOException {
		//user click mouse on the enter button
		String userInput = txtBoxCommand.getText();
		executeCommand(userInput);
	}

	/**This method will execute the command based on the command that is given
	 * Parameters: 		userInput - the command that is entered by the user
	 * Returns:			boolean - true or false
	 * **/
	public boolean executeCommand(String userInput){
		String[] tokens = null;
		String parserOutput = "";
		String logicOutput = "";
		String command = "";

		this.mLog.logInfo(Constants.LOG_UI_RUN_ON_ENTER + userInput);
		MainParser mp = MainParser.validateInput(userInput);
		parserOutput = mp.getMessage();
		if(!parserOutput.equals(Constants.PARSER_MESSAGE_VALID_INPUT)){
			//display error
			this.setTextStatus(parserOutput);
			this.mLog.logInfo(Constants.LOG_UI_FAIL_VALIDATE_INPUT + parserOutput);
			return false; //fail
		}

		this.mLog.logInfo(Constants.LOG_UI_SUCCESS_VALIDATE_INPUT + parserOutput);

		command = mp.getCommand();

		if(command.equalsIgnoreCase(Constants.VALUE_HELP)){
			showHelp();
			this.setTextStatus(Constants.LOGIC_SUCCESS_HELP);
			return true;
		}

		tokens = mp.getTokens();

		if(command.equalsIgnoreCase(Constants.VALUE_SEARCH)){
			this.setSearchKeyword(tokens);
			this.initTaskListInListView();
			this.setTextStatus(Constants.LOGIC_SUCCESS_SEARCH + searchKeyword);
			this.resetSearchKeyword();
			return true;
		}

		logicOutput = mLogic.runCommand(command, tokens);

		this.setTextStatus(logicOutput);
		this.initTaskListInListView();
		this.clearTextCommand();

		mLogic.storeToHistory(userInput);

		return true;
	}
	
	// End of segment: D:\install location\java\work\CS2103 PISTA\src\pista\ui\UIController.java





	/**
	 * origin: D:\install location\java\work\CS2103 PISTA\src\pista\ui\UIController.java
	 */

	/**This method will set text in the text field status
	 * Parameters:		msg - message that will be showing
	 * Returns:			boolean - true or false
	 * **/
	public boolean setTextStatus(String msg){
		if(this.txtStatus != null){
			this.txtStatus.setText(msg);
			return true;
		}
		return false;
	}
	
	// End of segment: D:\install location\java\work\CS2103 PISTA\src\pista\ui\UIController.java





	/**
	 * origin: D:\install location\java\work\CS2103 PISTA\src\pista\ui\UIController.java
	 */

	/**This method set the mainApp
	 * Parameters:		app - mainApp which the parent stage for UIController
	 * **/
	public void setMainAppController(MainApp app){
		this.mApp = app;
	}
	
	// End of segment: D:\install location\java\work\CS2103 PISTA\src\pista\ui\UIController.java





	/**
	 * origin: D:\install location\java\work\CS2103 PISTA\src\pista\ui\UIController.java
	 */

	/**This method will add controls which belongs to the top area
	 * **/
	private void addControlsToTopArea(){
		this.addControlsToAnchorPaneAreaTop(this.btnSetting, 0.0, 5.0, 0.0, 0.0);
		this.addControlsToAnchorPaneAreaTop(this.btnAddNewTask, 0.0, 45.0, 0.0, 0.0);
		this.addControlsToAnchorPaneAreaTop(this.btnRefresh, 0.0, 85.0, 0.0, 0.0);
		this.addControlsToAnchorPaneAreaTop(this.btnHelp, 0.0, 125.0, 0.0, 0.0);
		this.addControlsToAnchorPaneAreaTop(this.btnUndo, 0.0, 0.0, 0.0, 5.0);
		this.addControlsToAnchorPaneAreaTop(this.btnRedo, 0.0, 0.0, 0.0, 70.0);
	}
	
	// End of segment: D:\install location\java\work\CS2103 PISTA\src\pista\ui\UIController.java





	/**
	 * origin: D:\install location\java\work\CS2103 PISTA\src\pista\ui\UIController.java
	 */

	/**This method will initialize and start the clock at the bottom right corner of Pista 
	 * **/
	private void initTimeClock(){
		this.txtClock.getStyleClass().addAll(Constants.UI_CSS_TEXT_CLOCK);
		this.txtClock.setTextAlignment(TextAlignment.RIGHT);

		try{
			Timeline mTimeLine = new Timeline(new KeyFrame(Duration.seconds(0),
				new EventHandler<ActionEvent>(){
					DateFormat dateFormat = new SimpleDateFormat(Constants.DATETIME_FORMAT_CLOCK);
					@Override
					public void handle(ActionEvent event) {
						Calendar nowDate = Calendar.getInstance();
						txtClock.setText(dateFormat.format(nowDate.getTime()));
					}
				}),
			new KeyFrame(Duration.seconds(1))
			);
	
			mTimeLine.setCycleCount(Animation.INDEFINITE);
			mTimeLine.play();
			
		}catch(Exception e){
			mLog.logSevere(e.getMessage());
		}
	}

	// End of segment: D:\install location\java\work\CS2103 PISTA\src\pista\ui\UIController.java





	/**
	 * origin: D:\install location\java\work\CS2103 PISTA\src\pista\ui\UIController.java
	 */

	/**This method will initialize and start reminder
	 * **/
	private void initReminder(){
		try{
			Timeline aTimeLine = new Timeline(new KeyFrame(Duration.seconds(0),
				new EventHandler<ActionEvent>(){
					@Override
					public void handle(ActionEvent event) {
						runReminder();
					}//end handle
				}),
			new KeyFrame(Duration.seconds(1))
			);
			aTimeLine.setCycleCount(Animation.INDEFINITE);
			aTimeLine.play();
			
		}catch(Exception e){
			mLog.logSevere(e.getMessage());
		}
	}

	// End of segment: D:\install location\java\work\CS2103 PISTA\src\pista\ui\UIController.java





	/**
	 * origin: D:\install location\java\work\CS2103 PISTA\src\pista\ui\UIController.java
	 */

	/**This method will initialize the main parser
	 * **/
	private boolean initMainParser(){
		try{
			//this.mParser = MainParser.getInstance();
			return true;
		}catch(Exception e){
			e.printStackTrace();
			mLog.logSevere(e.getMessage());
			return false;
		}
	}

	// End of segment: D:\install location\java\work\CS2103 PISTA\src\pista\ui\UIController.java





	/**
	 * origin: D:\install location\java\work\CS2103 PISTA\src\pista\ui\UIController.java
	 */

	/**This method will initialize storage
	 * **/
	private boolean initStorage(){
		try{
			this.mStorage = Storage.getInstance();
			return true;
		}catch(Exception e){
			e.printStackTrace();
			mLog.logSevere(e.getMessage());
			return false;
		}		
	}

	/**This method will initialize the logic
	 * **/
	private boolean initLogic(){
		try{
			this.mLogic = Logic.getInstance();
			return true;
		}catch(Exception e){
			e.printStackTrace();
			mLog.logSevere(e.getMessage());
			return false;
		}
	}

	// End of segment: D:\install location\java\work\CS2103 PISTA\src\pista\ui\UIController.java





	/**
	 * origin: D:\install location\java\work\CS2103 PISTA\src\pista\ui\UIController.java
	 */

	/**This method will initialize preferences
	 * **/
	private boolean initPreferences(){
		try{
			this.mPrefs = CustomPreferences.getInstance();
			this.mPrefs.initPreference(Constants.PREFERENCE_URL_PATH);
			return true;
		}catch(Exception e){
			e.printStackTrace();
			mLog.logSevere(e.getMessage());
			return false;
		}
	}

	// End of segment: D:\install location\java\work\CS2103 PISTA\src\pista\ui\UIController.java





	/**
	 * origin: D:\install location\java\work\CS2103 PISTA\src\pista\ui\UIController.java
	 */

	/**This method will initialize logging
	 * **/
	private boolean initLogging(){
		try{
			this.mLog = CustomLogging.getInstance(Storage.class.getName());
			return true;
		}catch(Exception e){
			e.printStackTrace();
			return false;
		}		
	}

	// End of segment: D:\install location\java\work\CS2103 PISTA\src\pista\ui\UIController.java





	/**
	 * origin: D:\install location\java\work\CS2103 PISTA\src\pista\ui\UIController.java
	 */

	/**This method will initialize the start/quick guide,
	 * styling and adding control to the start guide
	 * **/
	private void initStartGuide(){
		if(this.anchorPaneStartGuide == null){
			this.anchorPaneStartGuide = new AnchorPane();
		}

		this.anchorPaneStartGuide.getStyleClass().addAll(Constants.UI_CSS_START_GUIDE_PANE);
		this.anchorPaneStartGuide.setPrefWidth(Constants.UI_START_GUIDE_WIDTH);
		this.anchorPaneStartGuide.setPrefHeight(Constants.UI_START_GUIDE_HEIGHT);

		btnOkStartGuide = new Button(Constants.UI_START_GUIDE_BUTTON_OK_TITLE);
		btnOkStartGuide.getStyleClass().addAll(Constants.UI_CSS_START_GUIDE_BUTTON);
		btnOkStartGuide.setPrefSize(Constants.UI_START_GUIDE_BUTTON_OK_WIDTH, Constants.UI_START_GUIDE_BUTTON_OK_HEIGHT);
		btnOkStartGuide.addEventFilter(ActionEvent.ACTION, onBtnStartGuideClick);

		this.anchorPaneStartGuide.getChildren().add(btnOkStartGuide);
		AnchorPane.setRightAnchor(btnOkStartGuide, Constants.UI_START_GUIDE_BUTTON_OK_ANCHOR_RIGHT);
		AnchorPane.setTopAnchor(btnOkStartGuide, Constants.UI_START_GUIDE_BUTTON_OK_ANCHOR_TOP);

		this.mStackPane.setPadding(new Insets(0,0,0,0));
		this.mStackPane.getChildren().add(1, this.anchorPaneStartGuide);
	}

	// End of segment: D:\install location\java\work\CS2103 PISTA\src\pista\ui\UIController.java





	/**
	 * origin: D:\install location\java\work\CS2103 PISTA\src\pista\ui\UIController.java
	 */

	/**This method will hide the start guide
	 * **/
	private void hideStartGuide(){
		this.mStackPane.getChildren().removeAll(this.anchorPaneStartGuide);
	}

	// End of segment: D:\install location\java\work\CS2103 PISTA\src\pista\ui\UIController.java





	/**
	 * origin: D:\install location\java\work\CS2103 PISTA\src\pista\ui\UIController.java
	 */

	/**This method will initialize the button redo which involves styling
	 * **/
	private void initButtonRedo(){
		ImageView img = new ImageView(new Image(Constants.UI_REDO_IMAGE_LINK));
		img.setPreserveRatio(true);
		img.setFitHeight(Constants.UI_IMG_INSIDE_BUTTON_WIDTH);
		img.setFitWidth(Constants.UI_IMG_INSIDE_BUTTON_HEIGHT);

		if(this.btnRedo == null){
			this.btnRedo = new Button(Constants.UI_REDO_BUTTON_TITLE); //
		}

		setButtonToolTip(this.btnRedo, Constants.UI_TOOLTIP_UNDO);
		this.btnRedo.setTextAlignment(TextAlignment.RIGHT);
		this.btnRedo.getStyleClass().addAll(Constants.UI_CSS_BUTTON_IMAGE, Constants.UI_CSS_BUTTON_REDO);
		this.btnRedo.setPrefWidth(Constants.UI_BUTTON_IMAGE_TOP_WIDTH);
		this.btnRedo.setPrefHeight(Constants.UI_BUTTON_TOP_HEIGHT);
		this.btnRedo.addEventFilter(ActionEvent.ACTION, onBtnRedoClick); //set click method listener
	}

	// End of segment: D:\install location\java\work\CS2103 PISTA\src\pista\ui\UIController.java





	/**
	 * origin: D:\install location\java\work\CS2103 PISTA\src\pista\ui\UIController.java
	 */

	/**This method will initialize the button undo which involves styling
	 * **/
	private void initButtonUndo(){
		if(this.btnUndo == null){
			this.btnUndo = new Button("Undo");
		}

		this.setButtonToolTip(this.btnUndo, Constants.UI_TOOLTIP_REDO);
		this.btnUndo.setTextAlignment(TextAlignment.RIGHT);
		this.btnUndo.getStyleClass().addAll(Constants.UI_CSS_BUTTON_IMAGE, Constants.UI_CSS_BUTTON_UNDO);
		this.btnUndo.setPrefWidth(Constants.UI_BUTTON_IMAGE_TOP_WIDTH);
		this.btnUndo.setPrefHeight(Constants.UI_BUTTON_TOP_HEIGHT);
		this.btnUndo.addEventFilter(ActionEvent.ACTION, this.onBtnUndoClick); //set click method listener
	}

	// End of segment: D:\install location\java\work\CS2103 PISTA\src\pista\ui\UIController.java





	/**
	 * origin: D:\install location\java\work\CS2103 PISTA\src\pista\ui\UIController.java
	 */

	/**This method will initialize the button setting which involves styling
	 * **/
	private void initButtonSetting(){
		if(this.btnSetting == null){
			this.btnSetting = new Button();
		}

		this.setButtonToolTip(this.btnSetting, Constants.UI_TOOLTIP_SETTING);
		this.btnSetting.getStyleClass().addAll(Constants.UI_CSS_BUTTON_IMAGE, Constants.UI_CSS_BUTTON_SETTING);
		this.btnSetting.setPrefSize(Constants.UI_BUTTON_TOP_WIDTH, Constants.UI_BUTTON_TOP_HEIGHT);
		this.btnSetting.addEventFilter(ActionEvent.ACTION, this.onBtnSettingClick); //set click method listener
	}

	// End of segment: D:\install location\java\work\CS2103 PISTA\src\pista\ui\UIController.java





	/**
	 * origin: D:\install location\java\work\CS2103 PISTA\src\pista\ui\UIController.java
	 */

	/**This method will initialize the button add new task which involves styling
	 * **/
	private void initButtonAddNewTask(){
		if(this.btnAddNewTask == null){
			this.btnAddNewTask = new Button();
		}

		setButtonToolTip(this.btnAddNewTask, Constants.UI_TOOLTIP_ADD);
		this.btnAddNewTask.getStyleClass().addAll(Constants.UI_CSS_BUTTON_IMAGE, Constants.UI_CSS_BUTTON_ADD);
		this.btnAddNewTask.setPrefSize(Constants.UI_BUTTON_TOP_WIDTH, Constants.UI_BUTTON_TOP_HEIGHT);
		this.btnAddNewTask.addEventFilter(ActionEvent.ACTION, this.onBtnAddNewTaskClick); //set click method listener
	}

	// End of segment: D:\install location\java\work\CS2103 PISTA\src\pista\ui\UIController.java





	/**
	 * origin: D:\install location\java\work\CS2103 PISTA\src\pista\ui\UIController.java
	 */

	/**This method will initialize the button help which involves styling
	 * **/
	private void initButtonHelp(){
		if(this.btnHelp == null){
			this.btnHelp = new Button();
		}

		setButtonToolTip(this.btnHelp, Constants.UI_TOOLTIP_HELP);
		this.btnHelp.getStyleClass().addAll(Constants.UI_CSS_BUTTON_IMAGE, Constants.UI_CSS_BUTTON_HELP);
		this.btnHelp.setPrefSize(Constants.UI_BUTTON_TOP_WIDTH, Constants.UI_BUTTON_TOP_HEIGHT);
		this.btnHelp.addEventFilter(ActionEvent.ACTION, this.onBtnHelpClick); //set click method listener
	}
	
	// End of segment: D:\install location\java\work\CS2103 PISTA\src\pista\ui\UIController.java





	/**
	 * origin: D:\install location\java\work\CS2103 PISTA\src\pista\ui\UIController.java
	 */

	/**This method will initialize the button refresh which involves styling
	 * **/
	private void initButtonRefresh(){
		if(this.btnRefresh == null){
			this.btnRefresh = new Button();
		}

		setButtonToolTip(this.btnRefresh, Constants.UI_TOOLTIP_REFRESH);
		this.btnRefresh.getStyleClass().addAll(Constants.UI_CSS_BUTTON_IMAGE, Constants.UI_CSS_BUTTON_REFRESH);
		this.btnRefresh.setPrefSize(Constants.UI_BUTTON_TOP_WIDTH, Constants.UI_BUTTON_TOP_HEIGHT);
		this.btnRefresh.addEventFilter(ActionEvent.ACTION, this.onBtnRefreshClick); //set click method listener
	}

	// End of segment: D:\install location\java\work\CS2103 PISTA\src\pista\ui\UIController.java





	/**
	 * origin: D:\install location\java\work\CS2103 PISTA\src\pista\ui\UIController.java
	 */

	/**This method will add controls(e.g. undo, redo, help, refresh, add, setting) to the top area 
	 * Parameter	mNode - refers to single control (e.g. button)
	 * 				anchorTop - double value
	 * 				anchorRight - double value
	 * 				anchorBottom - double value
	 * 				anchorLeft - double value
	 * **/
	private void addControlsToAnchorPaneAreaTop(Node mNode, double anchorTop, double anchorRight, double anchorBottom, double anchorLeft){
		this.anchorPaneButtonAreaTop.getChildren().add(mNode);
		AnchorPane.setTopAnchor(mNode, anchorTop);
		AnchorPane.setBottomAnchor(mNode, anchorBottom);

		if(!(anchorRight == 0.0)){
			AnchorPane.setRightAnchor(mNode, anchorRight);
		}

		if(!(anchorLeft == 0.0)){
			AnchorPane.setLeftAnchor(mNode, anchorLeft);
		}
	}

	// End of segment: D:\install location\java\work\CS2103 PISTA\src\pista\ui\UIController.java





	/**
	 * origin: D:\install location\java\work\CS2103 PISTA\src\pista\ui\UIController.java
	 */

	/**This method will get text from text field command
	 * Returns:			String - get text inside the text field command
	 * **/
	private String getTextCommand(){
		return this.txtBoxCommand.getText();
	}
		
	// End of segment: D:\install location\java\work\CS2103 PISTA\src\pista\ui\UIController.java





	/**
	 * origin: D:\install location\java\work\CS2103 PISTA\src\pista\ui\UIController.java
	 */

	/**This method will populate the first launch file location
	 * Usually is the default file path when Pista first launch on a desktop
	 * **/
	private String getNewLaunchFileLocation(){
		String defaultPath = Constants.USER_DIRECTORY + "" + Constants.SETTING_SAVE_AS_DEFAULT_XML_FILE_NAME;
		return defaultPath;
	}
	
	// End of segment: D:\install location\java\work\CS2103 PISTA\src\pista\ui\UIController.java





	/**
	 * origin: D:\install location\java\work\CS2103 PISTA\src\pista\ui\UIController.java
	 */

	/**This method will get the file location from preferences
	 * Usually from local user registry
	 * **/
	private String getPreferenceFilePath(){ //get file path from preference
		try{
			String filePath = "";
			filePath = this.mPrefs.getPreferenceFileLocation();
			return filePath;
		}catch(Exception e){
			e.printStackTrace();
			return "";
		}
	}
		
	// End of segment: D:\install location\java\work\CS2103 PISTA\src\pista\ui\UIController.java





	/**
	 * origin: D:\install location\java\work\CS2103 PISTA\src\pista\ui\UIController.java
	 */

	/**This method will get the launch flag from preferences
	 * Usually from local user registry
	 * **/
	private int getPreferencePistaFlag(){
		try{
			int flag = 0; //either 1 or 0
			flag = this.mPrefs.getPreferencePistaFlag();
			return flag;
		}catch(Exception e){
			e.printStackTrace();
			return Constants.PREFERENCE_ERROR_LAUNCH_VALUE;
		}
	}

	// End of segment: D:\install location\java\work\CS2103 PISTA\src\pista\ui\UIController.java





	/**
	 * origin: D:\install location\java\work\CS2103 PISTA\src\pista\ui\UIController.java
	 */

	/**This method will set the launch flag from preferences
	 * Usually from local user registry
	 * **/
	private boolean setPreferencePistaFlag(int flag){
		try{
			this.mPrefs.setPreferencePistaFlag(flag);
			return true;
		}catch(Exception e){
			e.printStackTrace();
			return false;
		}
	}

	// End of segment: D:\install location\java\work\CS2103 PISTA\src\pista\ui\UIController.java





	/**
	 * origin: D:\install location\java\work\CS2103 PISTA\src\pista\ui\UIController.java
	 */

	/**This method will set the file location from preferences
	 * Usually from local user registry
	 * **/
	private boolean setPreferenceFilePath(String newPath){ //set new file path from preference
		try{
			this.mPrefs.setPreferenceFileLocation(newPath);
			return true;
		}catch(Exception e){
			e.printStackTrace();
			return false;
		}
	}

	// End of segment: D:\install location\java\work\CS2103 PISTA\src\pista\ui\UIController.java





	/**
	 * origin: D:\install location\java\work\CS2103 PISTA\src\pista\ui\UIController.java
	 */

	/**This method will set text in the tooltip for buttons
	 * Parameters:		btn - a button that will be adding a tooltip
	 * 					msg - message that will be showing
	 * Returns:			boolean - true or false
	 * **/
	private boolean setButtonToolTip(Button btn, String msg){
		try{
			if(btn != null){
				btn.setTooltip(new Tooltip(msg));
				return true;
			}
			return false;
		}catch(Exception e){
			e.printStackTrace();
			return false;
		}		
	}

	

	// End of segment: D:\install location\java\work\CS2103 PISTA\src\pista\ui\UIController.java





	/**
	 * origin: D:\install location\java\work\CS2103 PISTA\src\pista\ui\UIController.java
	 */

	/**This method will initialize the task list view which populate all the task from XML 
	 * Returns:			boolean - true or false
	 * **/
	public boolean initTaskListInListView(){
		try{
			ArrayList<Task> storageList = null;
			mLogic.reorderStorageList();
			storageList = mLogic.getStorageList();

			if (this.searchKeyword != null) {
				storageList = searchTasks(storageList, this.searchKeyword);
			}

			ObservableList<Task> myObservableList = FXCollections.observableList(storageList);
			this.listviewTask.setItems(null); 
			this.listviewTask.setItems(myObservableList);
			this.listviewTask.getStyleClass().addAll(Constants.UI_CSS_LIST_VIEW); //add css class
			this.listviewTask.setCellFactory(new Callback<ListView<Task>, ListCell<Task>>(){ //populate every task into a custom cell
				@Override
				public ListCell<Task> call(ListView<Task> param) {
					final TaskListCell mCell = new TaskListCell();
					mCell.setUIParent(UIController.this);
					return mCell;
				}//end call
			});

			//Selected item
			//currently not in use
			this.listviewTask.getSelectionModel().selectedItemProperty().addListener(new ChangeListener<Task>() {
				@Override      
				public void changed(ObservableValue<? extends Task> ov,
						Task oldTask, Task newTask) {
				}
			});

			return true;
		}catch(Exception e){
			this.mLog.logSevere(e.getMessage());
			return false;
		}//end try

	}//end initTaskListInListView

	// End of segment: D:\install location\java\work\CS2103 PISTA\src\pista\ui\UIController.java





	/**
	 * origin: D:\install location\java\work\CS2103 PISTA\src\pista\ui\UIController.java
	 */

	/**This method will create and show the help guide
	 * Returns:			boolean - true or false
	 * **/
	public boolean showHelp(){
		try{
			if(this.stageHelp == null){
				this.stageHelp = new Stage();
			}
	
			double startX = this.mApp.getPrimaryStage().getX() + this.mApp.getPrimaryStageWidth();
			double startY = this.mApp.getPrimaryStage().getY();
	
			this.stageHelp.setTitle(Constants.HELP_TITLE);
			this.stageHelp.initStyle(StageStyle.UTILITY);
			this.stageHelp.initModality(Modality.NONE);
			this.stageHelp.setResizable(false);
			this.stageHelp.setX(startX);
			this.stageHelp.setY(startY);
	
			Scene scene = new Scene(new Browser(), 500, 700, Color.web("#666970"));
			this.stageHelp.setScene(scene);    
			this.stageHelp.show();
	
			return true;
		}catch(Exception e){
			e.printStackTrace();
			return false;
		}
	}

	// End of segment: D:\install location\java\work\CS2103 PISTA\src\pista\ui\UIController.java





	/**
	 * origin: D:\install location\java\work\CS2103 PISTA\src\pista\ui\UIController.java
	 */

	/**This method will return the help guide stages
	 * Returns:		Stage - get the help guide stage
	 * **/
	public Stage getHelpStage(){
		return this.stageHelp;
	}

	// End of segment: D:\install location\java\work\CS2103 PISTA\src\pista\ui\UIController.java





	/**
	 * origin: D:\install location\java\work\CS2103 PISTA\src\pista\ui\UIController.java
	 */

	/**This method will set text in the text field command
	 * **/
	private void clearTextCommand(){
		this.txtBoxCommand.clear();
	}

	/**This method is to handle the auto-complete command when user press Ctrl+Space
	 * **/
	private void onCtrlSpacePressed(){
		this.userInput = this.getTextCommand();
		String[] temp = this.userInput.split("\\s+",2);
		String command = temp[0];
		try { 
			int id = Integer.parseInt(temp[1]);
			if( command.equalsIgnoreCase("edit")){
				String processedString = mLogic.processTaskInfo(id);
				String finalStr = processedString;
				
				this.setAppendTextCommand(finalStr);			
			}
		}catch(NumberFormatException e) {
			e.printStackTrace();
		}
	}


	/**This method is to toggle the history commands when user press Up
	 * **/
	private void onUpPressed(){
		if(Constants.HISTORY_INDEX > 0){
			Constants.HISTORY_INDEX -= 1;
			this.setTextCommand(this.mStorage.getHistoryList().get(Constants.HISTORY_INDEX));
		}else{
			this.setTextCommand(this.mStorage.getHistoryList().get(0));
		}
	}


	/**This method is to toggle the history commands when user press Down
	 * **/
	private void onDownPressed(){
		if(Constants.HISTORY_INDEX < this.mStorage.getHistoryList().size() - 1){
			Constants.HISTORY_INDEX += 1;
			this.setTextCommand(this.mStorage.getHistoryList().get(Constants.HISTORY_INDEX));
		}else{
			Constants.HISTORY_INDEX = this.mStorage.getHistoryList().size();
			this.clearTextCommand();
		}
	}

	// End of segment: D:\install location\java\work\CS2103 PISTA\src\pista\ui\UIController.java





	/**
	 * origin: D:\install location\java\work\CS2103 PISTA\src\pista\ui\UIController.java
	 */

	/**This method will set text in the text field command
	 * **/
	private void setTextCommand(String command){
		this.txtBoxCommand.setText(command);
	}
	
	// End of segment: D:\install location\java\work\CS2103 PISTA\src\pista\ui\UIController.java





	/**
	 * origin: D:\install location\java\work\CS2103 PISTA\src\pista\ui\UIController.java
	 */

	/**This method will append text in the text field command
	 * with the cursor moving to the front
	 * **/
	private void setAppendTextCommand(String command){
		this.txtBoxCommand.appendText(command);
	}
	
	

	// End of segment: D:\install location\java\work\CS2103 PISTA\src\pista\ui\UIController.java





	/**
	 * origin: D:\install location\java\work\CS2103 PISTA\src\pista\ui\UIController.java
	 */

	/**This method is to show the pop over add
	 * **/
	private void showPopOverAdd(){
		this.mPopOverAdd.show(this.btnAddNewTask);
	}
	
	// End of segment: D:\install location\java\work\CS2103 PISTA\src\pista\ui\UIController.java





	/**
	 * origin: D:\install location\java\work\CS2103 PISTA\src\pista\ui\UIController.java
	 */

	/**This method is to show the pop over setting
	 * **/
	private void showPopOverSetting(){
		this.mPopOverSetting.show(this.btnSetting); 
	}

	// End of segment: D:\install location\java\work\CS2103 PISTA\src\pista\ui\UIController.java





	/**
	 * origin: D:\install location\java\work\CS2103 PISTA\src\pista\ui\UIController.java
	 */

	/**This method is to initialize the pop over add
	 * **/
	private void initPopOverAdd(){
		VBox vBox = new VBox(Constants.UI_POP_OVER_VBOX_SPACING);
		HBox hBox = new HBox(Constants.UI_POP_OVER_HBOX_SPACING);

		final TextArea txtAreaTaskTitle = new TextArea();
		Label lblTitle = new Label(Constants.UI_POP_OVER_ADD_TITLE);
		Label lblDateTitle = new Label(Constants.UI_POP_OVER_START_DATE_TITLE);
		Label lblTimeTitle = new Label(Constants.UI_POP_OVER_START_TIME_TITLE);
		Label lblTimeTip = new Label(Constants.UI_POP_OVER_TIME_TIP);
		Label lblColon = new Label(Constants.UI_POP_OVER_COLON);
		final DatePicker datePickerStartDate = new DatePicker(); //start date
		final DatePicker datePickerEndDate = new DatePicker(); //start date
		final TextField txtFieldStartHour = new TextField(); //end hour
		final TextField txtFieldStartMin = new TextField(); //end min
		final TextField txtFieldEndHour = new TextField(); //end hour
		final TextField txtFieldEndMin = new TextField(); //end min

		Button btnAdd = new Button(Constants.UI_POP_OVER_ADD_BUTTON_ADD);
		final Label lblMessage = new Label();

		if(this.mPopOverAdd != null){
			if(this.mPopOverAdd.isShowing()){
				this.mPopOverAdd.setAutoHide(true);
				return;
			}
		}

		datePickerStartDate.setPromptText(Constants.UI_POP_OVER_ADD_DATEPICKER_START_DATE_PROMPT_TEXT);
		datePickerStartDate.setConverter(datePickerStringConverter);
		datePickerEndDate.setPromptText(Constants.UI_POP_OVER_ADD_DATEPICKER_END_DATE_PROMPT_TEXT);
		datePickerEndDate.setConverter(datePickerStringConverter);

		setPopOverLabelTitle(lblTitle, Constants.UI_POP_OVER_ADD_WIDTH); //style the label title 
		setPopOverLabelDateTime(lblDateTitle, lblTimeTitle, Constants.UI_POP_OVER_LABEL_DATETIME_WIDTH); //style the labels 
		setPopOverTextFieldHourMinute(txtFieldStartHour, txtFieldStartMin);
		setPopOverLabelTimeTip(lblTimeTip);
		
		txtAreaTaskTitle.getStyleClass().addAll(Constants.UI_CSS_POP_OVER_TEXTAREA);
		txtAreaTaskTitle.setPrefRowCount(3); //text area
		txtAreaTaskTitle.setPrefWidth(Constants.UI_POP_OVER_ADD_WIDTH);
		txtAreaTaskTitle.setWrapText(true);
		txtAreaTaskTitle.setPromptText("Type in a new task title");

		vBox.getChildren().add(lblTitle); //add title
		vBox.getChildren().add(txtAreaTaskTitle); //add task title

		hBox = new HBox(Constants.UI_POP_OVER_HBOX_SPACING); //start date
		hBox.getChildren().add(lblDateTitle); 
		hBox.getChildren().add(datePickerStartDate);
		vBox.getChildren().add(hBox);

		hBox = new HBox(Constants.UI_POP_OVER_HBOX_SPACING); //start hour and minute		
		hBox.getChildren().add(lblTimeTitle);  
		hBox.getChildren().add(txtFieldStartHour);
		hBox.getChildren().add(lblColon);
		hBox.getChildren().add(txtFieldStartMin);
		hBox.getChildren().add(lblTimeTip);
		HBox.setMargin(lblTimeTip, new Insets(Constants.UI_POP_OVER_HBOX_MARGIN_TOP,
												Constants.UI_POP_OVER_HBOX_MARGIN_RIGHT,
												Constants.UI_POP_OVER_HBOX_MARGIN_BOTTOM,
												Constants.UI_POP_OVER_HBOX_MARGIN_LEFT));
		vBox.getChildren().add(hBox);

		lblDateTitle = new Label(Constants.UI_POP_OVER_END_DATE_TITLE);
		lblTimeTitle = new Label(Constants.UI_POP_OVER_END_TIME_TITLE);
		lblTimeTip = new Label(Constants.UI_POP_OVER_TIME_TIP);
		lblColon = new Label(Constants.UI_POP_OVER_COLON);

		setPopOverLabelDateTime(lblDateTitle, lblTimeTitle, Constants.UI_POP_OVER_LABEL_DATETIME_WIDTH); //style the labels again
		setPopOverTextFieldHourMinute(txtFieldEndHour, txtFieldEndMin);
		setPopOverLabelTimeTip(lblTimeTip);

		hBox = new HBox(Constants.UI_POP_OVER_HBOX_SPACING); //end date 
		hBox.getChildren().add(lblDateTitle); //start date
		hBox.getChildren().add(datePickerEndDate);
		vBox.getChildren().add(hBox);

		hBox = new HBox(Constants.UI_POP_OVER_HBOX_SPACING); //end hour and minute
		hBox.getChildren().add(lblTimeTitle);  
		hBox.getChildren().add(txtFieldEndHour);
		hBox.getChildren().add(lblColon);
		hBox.getChildren().add(txtFieldEndMin);
		hBox.getChildren().add(lblTimeTip);
		HBox.setMargin(lblTimeTip, new Insets(Constants.UI_POP_OVER_HBOX_MARGIN_TOP,
												Constants.UI_POP_OVER_HBOX_MARGIN_RIGHT,
												Constants.UI_POP_OVER_HBOX_MARGIN_BOTTOM,
												Constants.UI_POP_OVER_HBOX_MARGIN_LEFT));
		vBox.getChildren().add(hBox);
		VBox.setMargin(btnAdd, new Insets(Constants.UI_POP_OVER_VBOX_MARGIN_TOP,
											Constants.UI_POP_OVER_VBOX_MARGIN_RIGHT,
											Constants.UI_POP_OVER_VBOX_MARGIN_BOTTOM,
											Constants.UI_POP_OVER_VBOX_MARGIN_LEFT));
		vBox.setPadding(new Insets(Constants.UI_POP_OVER_VBOX_PADDING_INSETS_TOP, Constants.UI_POP_OVER_VBOX_PADDING_INSETS_RIGHT, 
					Constants.UI_POP_OVER_VBOX_PADDING_INSETS_BOTTOM, Constants.UI_POP_OVER_VBOX_PADDING_INSETS_LEFT)); //set Padding

		vBox.getChildren().add(btnAdd); //add edit button
		vBox.getChildren().add(lblMessage); //add message
		vBox.setPrefSize(Constants.UI_POP_OVER_ADD_WIDTH, Constants.UI_POP_OVER_ADD_HEIGHT); //set size
		vBox.getStyleClass().addAll(Constants.UI_CSS_POP_OVER_CONTENT_AREA); //set style

		this.mPopOverAdd = new PopOver(vBox);
		this.mPopOverAdd.setHideOnEscape(true);
		this.mPopOverAdd.setArrowLocation(PopOver.ArrowLocation.LEFT_TOP);
		this.mPopOverAdd.setAutoFix(true);
		this.mPopOverAdd.setAutoHide(true);
		this.mPopOverAdd.setDetachable(false);

		btnAdd.getStyleClass().addAll(Constants.UI_CSS_POP_OVER_BUTTON);
		btnAdd.setPrefWidth(Constants.UI_POP_OVER_ADD_WIDTH);
		btnAdd.addEventFilter(ActionEvent.ACTION, new EventHandler<ActionEvent>() {
			@Override
			public void handle(ActionEvent event) {
				boolean isCreated = false;

				LocalDate rawStartDate = datePickerStartDate.getValue();
				LocalDate rawEndDate = datePickerEndDate.getValue();

				String newTitle = txtAreaTaskTitle.getText(); //new title
				String newStartDate = convertDateToStorageFormat(rawStartDate); //new start date
				String newEndDate = convertDateToStorageFormat(rawEndDate); //new end date
				String newStartHour = txtFieldStartHour.getText(); //new start hour
				String newStartMinute = txtFieldStartMin.getText(); //new start minute
				String newEndHour = txtFieldEndHour.getText(); //new end hour
				String newEndMinute = txtFieldEndMin.getText(); //new end minute

				String newStartTime = "";
				String newEndTime = "";
				String addCommand = Constants.UI_POP_OVER_ADD_TASK_COMMAND;

				//e.g. addTaskCommand = "add [task_title] -[start_date] -[start_time] -[end_date] -[end_time]";
				if(!isTitleValid(newTitle)){ //check title
					setPopOverLabelMessageVisible(lblMessage, false, true); //show error message
					setPopOverLabelMessageText(lblMessage, Constants.UI_POP_OVER_INVALID_TITLE_MESSAGE);
					return;
				}

				if(!(isValidHour(newStartHour) && isValidMinute(newStartMinute))){ //check is valid for start hour and minute (accept empty)
					setPopOverLabelMessageVisible(lblMessage, false, true); //show error message
					setPopOverLabelMessageText(lblMessage, Constants.UI_POP_OVER_INVALID_START_TIME_MESSAGE);
					return;
				}

				if(!(isValidHour(newEndHour) && isValidMinute(newEndMinute))){ //check is valid for end hour and minute (accept empty)
					setPopOverLabelMessageVisible(lblMessage, false, true); //show error message
					setPopOverLabelMessageText(lblMessage, Constants.UI_POP_OVER_INVALID_END_TIME_MESSAGE);
					return;
				}

				//Check both start date and time
				if((newStartDate.equals("") || newStartDate.isEmpty()) && 
						(newStartHour.equals("") || newStartHour.isEmpty()) && 
						(newStartMinute.equals("") || newStartMinute.isEmpty())){ //start date, time is empty
	
					addCommand = addCommand.replace("-[start_date]", "").replace("-[start_time]", ""); //remove start date and time
					
				}else if(!(newStartDate.equals("") || newStartDate.isEmpty()) && 
						((newStartHour.equals("") || newStartHour.isEmpty()) ||
								(newStartMinute.equals("") || newStartMinute.isEmpty()))) { //date is not empty, but hour or minute is empty

					setPopOverLabelMessageVisible(lblMessage, false, true); //show error message
					setPopOverLabelMessageText(lblMessage, Constants.UI_POP_OVER_INVALID_START_TIME_MESSAGE);
					return;

				}else{
					newStartTime = newStartHour + Constants.UI_POP_OVER_COLON + newStartMinute;
					addCommand = addCommand.replace("[start_date]", newStartDate).replace("[start_time]", newStartTime);
				}

				//Check both end date and time
				if((newEndDate.equals("") || newEndDate.isEmpty()) && 
						(newEndHour.equals("") || newEndHour.isEmpty()) && 
						(newEndMinute.equals("") || newEndMinute.isEmpty())){
					//start date, time is empty
					//remove start date and time
					addCommand = addCommand.replace("-[end_date]", "").replace("-[end_time]", "");
				}else if(!(newStartDate.equals("") || newStartDate.isEmpty()) && 
						((newEndHour.equals("") || newEndHour.isEmpty()) ||
								(newEndMinute.equals("") || newEndMinute.isEmpty()))) { //date is not empty, but hour or minute is empty

					setPopOverLabelMessageVisible(lblMessage, false, true); //show error message
					setPopOverLabelMessageText(lblMessage, Constants.UI_POP_OVER_INVALID_END_TIME_MESSAGE);
					return;

				}else{
					newEndTime = newEndHour + ":" + newEndMinute;
					addCommand = addCommand.replace("[end_date]", newEndDate).replace("[end_time]", newEndTime);
				}

				addCommand = addCommand.replace("[task_title]", newTitle);	

				isCreated = executeCommand(addCommand);	
				if(isCreated){
					setPopOverLabelMessageVisible(lblMessage, true, true); //show success message
					setPopOverLabelMessageText(lblMessage, Constants.UI_POP_OVER_SUCCESS_ADD_MESSAGE);
					return;
				}else{
					setPopOverLabelMessageVisible(lblMessage, false, true); //show error message
					setPopOverLabelMessageText(lblMessage, Constants.UI_POP_OVER_FAIL_ADD_MESSAGE);
					return;
				}

			}//end handle
		});

	}

	// End of segment: D:\install location\java\work\CS2103 PISTA\src\pista\ui\UIController.java





	/**
	 * origin: D:\install location\java\work\CS2103 PISTA\src\pista\ui\UIController.java
	 */

	/**This method is to initialize the pop over setting
	 * **/	
	private void initPopOverSetting(){
		final Label lblSettingTitle = new Label(Constants.UI_POP_OVER_SETTING_TITLE);
		final Label lblCurrentFileLocationTitle = new Label(Constants.UI_POP_OVER_SETTING_FILE_CURRENT_LOCATION_TITLE);
		final Label lblCurrentFileLocation = new Label("");
		final String currentFileDir = mPrefs.getPreferenceFileLocation(); //Get current file location from preference
		VBox vBox = new VBox(Constants.UI_POP_OVER_VBOX_SPACING);

		Button btnOpenFileBrowse = new Button(Constants.UI_POP_OVER_SETTING_BUTTON_OPEN_TITLE);
		Button btnSaveAsFileBrowse = new Button(Constants.UI_POP_OVER_SETTING_BUTTON_SAVE_AS_TITLE);

		if(this.mPopOverSetting != null){
			if(this.mPopOverSetting.isShowing()){
				this.mPopOverSetting.setAutoHide(true);
				return;
			}
		}
		
		if(!(currentFileDir.isEmpty() || currentFileDir == "")){
			lblCurrentFileLocation.setText(mPrefs.getPreferenceFileLocation());
		}

		//Button browse
		btnOpenFileBrowse.getStyleClass().addAll(Constants.UI_CSS_POP_OVER_BUTTON);
		btnOpenFileBrowse.setPrefWidth(Constants.UI_POP_OVER_SETTING_WIDTH);
		btnOpenFileBrowse.addEventFilter(ActionEvent.ACTION, new EventHandler<ActionEvent>() { //button browse click
			@Override
			public void handle(ActionEvent event) {
				mPopOverSetting.setAutoHide(false); //set hide to false when browse file

				try{
					String newPath = openFile(currentFileDir);

					isValidFilePath = mLogic.checkFileBeforeSave(newPath);
					if(isValidFilePath){
						isFileCreated = mLogic.checkFileDuringSave(newPath);

						if(isFileCreated){
							String status = Constants.UI_STATUS_SUCCESS_FILE_OPEN_MESSAGE.replace("[new_file_path]", newPath);
							setTextStatus(status);
						}else{
							//logging
							setTextStatus(Constants.UI_STATUS_FAIL_TO_LOAD_XML_FILE_PATH_MESSAGE);
						}

						isPrefSave = setPreferenceFilePath(newPath); //save preferences
						if(!isPrefSave){ //unable to save
							setTextStatus(Constants.UI_STATUS_FAIL_PREFERENCE_SAVE);

						}else{ //saved successfully
							mStorage.setDataFileLocation(newPath); //set new path to storage
							initTaskListInListView(); //refresh the listview 
							setPopOverLabelText(lblCurrentFileLocation, newPath);
						}

						setTextStatus(Constants.UI_STATUS_SUCCESS_FILE_OPEN_MESSAGE); //success message

					}else{
						setPopOverLabelText(lblCurrentFileLocation, currentFileDir); //set back to old file path 
						setTextStatus(Constants.UI_STATUS_INVALID_XML_FILE_PATH_MESSAGE); //failed message
					}
				}catch(AssertionError e){
					//log
					e.printStackTrace();
				}catch(Exception e){
					//log
					e.printStackTrace();
				}

				mPopOverSetting.setAutoHide(true); //set hide to true again after browsing
			}
		});

		//Button Save As 
		btnSaveAsFileBrowse.getStyleClass().addAll(Constants.UI_CSS_POP_OVER_BUTTON);
		btnSaveAsFileBrowse.setPrefWidth(Constants.UI_POP_OVER_SETTING_WIDTH);
		btnSaveAsFileBrowse.addEventFilter(ActionEvent.ACTION, new EventHandler<ActionEvent>() {
			@Override
			public void handle(ActionEvent event) {
				mPopOverSetting.setAutoHide(false); //set hide to false when browse file
				
				try{
					String newPath = saveAsFile(currentFileDir);

					isCopied = mLogic.copyFile(currentFileDir, newPath);
					if(isCopied){
						setTextStatus(Constants.UI_STATUS_SUCCESS_FILE_SAVE_AS_MESSAGE.replace("[new_file_path]", newPath));

						isPrefSave = setPreferenceFilePath(newPath); //save preferences
						if(!isPrefSave){ //unable to save
							setTextStatus(Constants.UI_STATUS_FAIL_PREFERENCE_SAVE);

						}else{ //saved successfully
							mStorage.setDataFileLocation(newPath); //set new path to storage
							initTaskListInListView(); //refresh the listview 

							setPopOverLabelText(lblCurrentFileLocation, newPath);
						}

					}else{
						setTextStatus(Constants.UI_STATUS_FAIL_FILE_SAVE_AS_MESSAGE);
					}

				}catch(AssertionError e){
					//log
					e.printStackTrace();
				}catch(Exception e){
					//log
					e.printStackTrace();
				}

				mPopOverSetting.setAutoHide(true); //set hide to true again after browsing
			}
		});		

		//label setting title
		lblSettingTitle.getStyleClass().addAll(Constants.UI_CSS_POP_OVER_TITLE);
		lblSettingTitle.setPrefWidth(Constants.UI_POP_OVER_SETTING_WIDTH);
		lblSettingTitle.setTextAlignment(TextAlignment.CENTER);
		lblSettingTitle.setAlignment(Pos.CENTER);

		vBox.setPadding(new Insets(Constants.UI_POP_OVER_VBOX_PADDING_INSETS_TOP, Constants.UI_POP_OVER_VBOX_PADDING_INSETS_RIGHT, 
					Constants.UI_POP_OVER_VBOX_PADDING_INSETS_BOTTOM, Constants.UI_POP_OVER_VBOX_PADDING_INSETS_LEFT)); //set Padding
		vBox.getChildren().add(lblSettingTitle);
		vBox.getChildren().add(lblCurrentFileLocationTitle);
		vBox.getChildren().add(lblCurrentFileLocation);
		vBox.getChildren().add(btnOpenFileBrowse);
		vBox.getChildren().add(btnSaveAsFileBrowse);

		vBox.setPrefSize(Constants.UI_POP_OVER_SETTING_WIDTH, Constants.UI_POP_OVER_SETTING_HEIGHT);
		vBox.getStyleClass().addAll(Constants.UI_CSS_POP_OVER_CONTENT_AREA); //set style for the vbox

		this.mPopOverSetting = new PopOver(vBox);
		this.mPopOverSetting.setHideOnEscape(true);
		this.mPopOverSetting.setArrowLocation(PopOver.ArrowLocation.LEFT_TOP);
		this.mPopOverSetting.setAutoFix(true);
		this.mPopOverSetting.setAutoHide(true);
		this.mPopOverSetting.setDetachable(false);
	}

	// End of segment: D:\install location\java\work\CS2103 PISTA\src\pista\ui\UIController.java





	/**
	 * origin: D:\install location\java\work\CS2103 PISTA\src\pista\ui\UIController.java
	 */

	/**This method set individual pop over label title style
	 * **/	
	private void setPopOverLabelTitle(Label lbl, double width){
		lbl.getStyleClass().addAll(Constants.UI_CSS_POP_OVER_TITLE);
		lbl.setPrefWidth(width);
		lbl.setTextAlignment(TextAlignment.CENTER);
		lbl.setAlignment(Pos.CENTER);
	}

	// End of segment: D:\install location\java\work\CS2103 PISTA\src\pista\ui\UIController.java





	/**
	 * origin: D:\install location\java\work\CS2103 PISTA\src\pista\ui\UIController.java
	 */

	/**This method set individual pop over label date time style
	 * **/	
	private void setPopOverLabelDateTime(Label lblDate, Label lblTime, double width){
		lblDate.setPrefWidth(width);
		lblDate.setAlignment(Pos.CENTER_RIGHT);
		lblTime.setPrefWidth(width);
		lblTime.setAlignment(Pos.CENTER_RIGHT);
	}

	// End of segment: D:\install location\java\work\CS2103 PISTA\src\pista\ui\UIController.java





	/**
	 * origin: D:\install location\java\work\CS2103 PISTA\src\pista\ui\UIController.java
	 */

	/**This method set individual pop over text field hour and minute style
	 * **/	
	private void setPopOverTextFieldHourMinute(TextField txtHr, TextField txtMin){
		txtHr.setPrefWidth(60.0);
		txtHr.setPromptText("HH");
		txtMin.setPrefWidth(60.0);
		txtMin.setPromptText("MM");
	}

	// End of segment: D:\install location\java\work\CS2103 PISTA\src\pista\ui\UIController.java





	/**
	 * origin: D:\install location\java\work\CS2103 PISTA\src\pista\ui\UIController.java
	 */

	/**This method set individual pop over label time tip style
	 * **/	
	private void setPopOverLabelTimeTip(Label lbl){
		lbl.getStyleClass().addAll(Constants.UI_CSS_POP_OVER_TOOLTIP); //set tip style (after the minute input)
	}

	// End of segment: D:\install location\java\work\CS2103 PISTA\src\pista\ui\UIController.java





	/**
	 * origin: D:\install location\java\work\CS2103 PISTA\src\pista\ui\UIController.java
	 */

	/**This method set individual pop over label message style
	 * **/	
	private void setPopOverLabelMessageVisible(Label lbl, boolean isValid, boolean isVisible){
		lbl.getStyleClass().removeAll(Constants.UI_CSS_POP_OVER_CORRECT_MESSAGE, Constants.UI_CSS_POP_OVER_ERROR_MESSAGE);
		if(isValid){ //valid, green background
			lbl.getStyleClass().addAll(Constants.UI_CSS_POP_OVER_CORRECT_MESSAGE);	
		}else{//invalid, red background
			lbl.getStyleClass().addAll(Constants.UI_CSS_POP_OVER_ERROR_MESSAGE);
		}
		lbl.setVisible(isVisible);
	}

	// End of segment: D:\install location\java\work\CS2103 PISTA\src\pista\ui\UIController.java





	/**
	 * origin: D:\install location\java\work\CS2103 PISTA\src\pista\ui\UIController.java
	 */

	/**This method set individual pop over label text
	 * **/	
	private void setPopOverLabelText(Label lbl, String msg){
		lbl.setText(msg);
	}

	// End of segment: D:\install location\java\work\CS2103 PISTA\src\pista\ui\UIController.java





	/**
	 * origin: D:\install location\java\work\CS2103 PISTA\src\pista\ui\UIController.java
	 */

	/**This method set individual pop over label message text
	 * **/	
	private void setPopOverLabelMessageText(Label lbl, String msg){
		lbl.setText(msg);
	}

	// End of segment: D:\install location\java\work\CS2103 PISTA\src\pista\ui\UIController.java





	/**
	 * origin: D:\install location\java\work\CS2103 PISTA\src\pista\ui\UIController.java
	 */

	/**This method will run the remainder
	 * **/
	private void runReminder(){
		for (int i = 0; i < mLogic.getStorageList().size(); i++) {
			Task extractedTask = mLogic.getStorageList().get(i);
			String taskTitle = extractedTask.getTitle();
			boolean taskIsReminded = extractedTask.getIsReminded();
			Long taskReminder = extractedTask.getReminder();
			Long taskEndMillisecond = extractedTask.getEndMilliseconds();
			Long timeNow = System.currentTimeMillis();

			if(taskReminder != 0L){
				if(timeNow >= taskReminder && !taskIsReminded){
					String datePattern = "dd MMMM yyyy"; //e.g. 18 January 2015
					SimpleDateFormat mDateFormat = new SimpleDateFormat(datePattern);
					String endDate = mDateFormat.format(new Date(taskEndMillisecond));

					//update the reminded status in the storage list
					mLogic.getStorageList().get(i).setIsReminded(true);

					showReminder("Upcoming task: " + taskTitle, 
							"Due on " + endDate);

					File file = new File (Constants.BUILD_PATH + Constants.UI_ALARM_LOCATION);
					playAlarm(file.toURI().toString());
				}
			}
		}
	}

	// End of segment: D:\install location\java\work\CS2103 PISTA\src\pista\ui\UIController.java





	/**
	 * origin: D:\install location\java\work\CS2103 PISTA\src\pista\ui\UIController.java
	 */

	/**This method show the remainder notification
	 * **/
	private void showReminder(String title, String msg){
		Notifications.create().title(title).text(msg).showWarning();	
	}

	// End of segment: D:\install location\java\work\CS2103 PISTA\src\pista\ui\UIController.java





	/**
	 * origin: D:\install location\java\work\CS2103 PISTA\src\pista\ui\UIController.java
	 */

	/**This method play the alarm sound
	 * Parameters:		url - valid alarm file path
	 * **/
	private void playAlarm(String url){
		Media alarm = new Media (url);
		startMediaPlayer(alarm);
	}

	// End of segment: D:\install location\java\work\CS2103 PISTA\src\pista\ui\UIController.java





	/**
	 * origin: D:\install location\java\work\CS2103 PISTA\src\pista\ui\UIController.java
	 */

	/**This method start media player which run the 
	 * Parameters:		m - string value
	 * **/
	private void startMediaPlayer(Media m){
		if(m != null){
			MediaPlayer mp = new MediaPlayer(m);
			mp.play();
		}
	}

		
	// End of segment: D:\install location\java\work\CS2103 PISTA\src\pista\ui\UIController.java





	/**
	 * origin: D:\install location\java\work\CS2103 PISTA\src\pista\ui\UIController.java
	 */

	/**This method opens the window environment file browser
	 * Only allow user to choose a XML file
	 * **/	
	private String openFile(String oldPath){
		FileChooser fileChooser = new FileChooser();
		FileChooser.ExtensionFilter extFilter = new FileChooser.ExtensionFilter(
					Constants.UI_POP_OVER_SETTING_FILE_EXTENSION_FILTER_1, Constants.UI_POP_OVER_SETTING_FILE_EXTENSION_FILTER_2);
		fileChooser.getExtensionFilters().add(extFilter);
		fileChooser.setInitialDirectory(new File(getUserDesktopDirectory())); //set init directory

		File file = fileChooser.showOpenDialog(null);

		if(file != null){
			if (!file.getPath().endsWith(Constants.XML_FILE_EXTENSION)) {
				file = new File(file.getPath() + Constants.XML_FILE_EXTENSION);
			}
			return file.getPath();
		}

		return oldPath;
	}

	// End of segment: D:\install location\java\work\CS2103 PISTA\src\pista\ui\UIController.java





	/**
	 * origin: D:\install location\java\work\CS2103 PISTA\src\pista\ui\UIController.java
	 */

	/**This method opens the window environment file browser
	 * Allow user to either specify a new file name or choose a file 
	 * **/
	private String saveAsFile(String oldPath){
		FileChooser fileChooser = new FileChooser();
		FileChooser.ExtensionFilter extFilter = new FileChooser.ExtensionFilter(
				Constants.UI_POP_OVER_SETTING_FILE_EXTENSION_FILTER_1, Constants.UI_POP_OVER_SETTING_FILE_EXTENSION_FILTER_2);
		fileChooser.getExtensionFilters().add(extFilter);
		fileChooser.setInitialDirectory(new File(getUserDesktopDirectory())); //set init directory

		File file = fileChooser.showSaveDialog(null);

		if(file != null){
			if (!file.getPath().endsWith(Constants.XML_FILE_EXTENSION)) {
				file = new File(file.getPath() + Constants.XML_FILE_EXTENSION);
			}
			return file.getPath();
		}

		return oldPath;
	}
	
	// End of segment: D:\install location\java\work\CS2103 PISTA\src\pista\ui\UIController.java





	/**
	 * origin: D:\install location\java\work\CS2103 PISTA\src\pista\ui\UIController.java
	 */

	/**This method get the default user desktop directory
	 * **/
	private String getUserDesktopDirectory(){
		return Constants.SETTING_DEFAULT_FOLDER_PATH;
	}	

	// End of segment: D:\install location\java\work\CS2103 PISTA\src\pista\ui\UIController.java





	/**
	 * origin: D:\install location\java\work\CS2103 PISTA\src\pista\ui\UIController.java
	 */

	/**This method get change the date format in datepicker
	 * Returns:		
	 * **/
	private StringConverter<LocalDate> datePickerStringConverter = new StringConverter<LocalDate>() {
		DateTimeFormatter dateFormatter = DateTimeFormatter.ofPattern(Constants.DATETIME_FORMAT_DATEPICKER); //e.g. 18 January 2015
		@Override 
		public String toString(LocalDate date) {
			if (date != null) {
				return dateFormatter.format(date);
			} else {
				return "";
			}
		}

		@Override 
		public LocalDate fromString(String string) {
			if (string != null && !string.isEmpty()) {
				return LocalDate.parse(string, dateFormatter);
			} else {
				return null;
			}
		}
	};

	// End of segment: D:\install location\java\work\CS2103 PISTA\src\pista\ui\UIController.java





	/**
	 * origin: D:\install location\java\work\CS2103 PISTA\src\pista\ui\UIController.java
	 */

	/**This method converts date to storage formatted date
	 * Parameters:		rawDate - LocalDate which is not in storage format
	 * Returns:			String - return storage date format d/M/yyyy
	 * **/
	private String convertDateToStorageFormat(LocalDate rawDate){ 
		DateTimeFormatter dateFormatter = DateTimeFormatter.ofPattern(Constants.DATETIME_FORMAT_STORAGE); //e.g. 18/4/2015
		if(rawDate == null){
			return "";
		}
		return dateFormatter.format(rawDate);
	}

	// End of segment: D:\install location\java\work\CS2103 PISTA\src\pista\ui\UIController.java





	/**
	 * origin: D:\install location\java\work\CS2103 PISTA\src\pista\ui\UIController.java
	 */

	/**This method validate the title string 
	 * Parameters:		title - string value
	 * Returns:			boolean - true or false
	 * **/
	private boolean isTitleValid(String title){
		if(title.isEmpty() || title.equals("")){ //don't accept empty
			return false;
		}
		return true;
	}

	// End of segment: D:\install location\java\work\CS2103 PISTA\src\pista\ui\UIController.java





	/**
	 * origin: D:\install location\java\work\CS2103 PISTA\src\pista\ui\UIController.java
	 */

	/**This method validate the hour string 
	 * Parameters:		hour - the hour value in string
	 * Returns:			boolean - true or false
	 * **/
	private boolean isValidHour(String hour){
		try{ //accept empty, means 0
			if(convertStringToInteger(hour) < 0 || convertStringToInteger(hour) > 23){
				return false;
			}
		}catch(NumberFormatException e){ //maybe hour contain alphabet
			e.printStackTrace();
			return false;
		}
		return true;
	}

	// End of segment: D:\install location\java\work\CS2103 PISTA\src\pista\ui\UIController.java





	/**
	 * origin: D:\install location\java\work\CS2103 PISTA\src\pista\ui\UIController.java
	 */

	/**This method validate the minute string 
	 * Parameters:		minute - the minute value in string
	 * Returns:			boolean - true or false
	 * **/
	private boolean isValidMinute(String minute){
		try{ //accept empty, means 0
			if(convertStringToInteger(minute) < 0 || convertStringToInteger(minute) > 60){
				return false;
			}
		}catch(NumberFormatException e){ //maybe hour contain alphabet
			e.printStackTrace();
			return false;
		}
		return true;
	}

	// End of segment: D:\install location\java\work\CS2103 PISTA\src\pista\ui\UIController.java





	/**
	 * origin: D:\install location\java\work\CS2103 PISTA\src\pista\ui\UIController.java
	 */

	private int convertStringToInteger(String s){
		if(s.equals("") || s.isEmpty()){
			return 0;
		}
		return Integer.parseInt(s);
	}

	//============================== SEARCH FUNCTIONS ====================================
	private void setSearchKeyword(String[] tokens) {
		this.searchKeyword = getKeyword(tokens);
		this.possibleKeywords = tokens;
	}

	private String getKeyword(String[] tokens) {
		return tokens[Constants.SEARCH_TOKEN_KEYWORD];
	}

	private void resetSearchKeyword() {
		this.searchKeyword = null;
		this.possibleKeywords = null;
	}

	private ArrayList<Task> searchTasks(ArrayList<Task> storageList, String keyword) {
		ArrayList<Task> displayList = new ArrayList<Task>();

		for (Task task: storageList) {
			if (hasKeyword(task, possibleKeywords)) {
				displayList.add(task);
			}
		}
		return displayList;
	}

	private boolean hasKeyword(Task task, String[] possibleKeywords) {
		String taskDescription = task.getTitle();
		String taskStartDate = task.getStartDate();
		String taskEndDate = task.getEndDate();
		String taskStartTime = task.getStartTime();
		String taskEndTime = task.getEndTime();

		//check if keyword exists in title of task
		String[] descriptionTokens = makeIntoTokens(taskDescription);

		for (String token: descriptionTokens) {
			if (token.equalsIgnoreCase(searchKeyword)) {
				return true;
			}
		}
		
		//check if keyword is a time
		String keywordAsTime = this.getTime();
		if (keywordAsTime != null) {
			if (keywordAsTime.equals(taskStartTime) || keywordAsTime.equals(taskEndTime)) {
				System.out.println("checking as time");
				return true;
			}
		}
				
		//check if keyword is a date
		String keywordAsDate = this.getDate();
		if (keywordAsDate != null) {
			if (keywordAsDate.equals(taskStartDate) || keywordAsDate.equals(taskEndDate)) {
				return true;
			}
		}
		
		return false;
	}

	private String[] makeIntoTokens(String taskDescription) {
		return taskDescription.split("\\s+");
	}
	
	private String getDate() {
		return this.possibleKeywords[Constants.SEARCH_KEYWORD_DATE];
	}
	
	private String getTime() {
		return this.possibleKeywords[Constants.SEARCH_KEYWORD_TIME];
	}

	// End of segment: D:\install location\java\work\CS2103 PISTA\src\pista\ui\UIController.java





	/**
	 * origin: D:\install location\java\work\CS2103 PISTA\src\pista\ui\UIController.java
	 */

	/**This method is to handle the click for button start guide 
	 * **/
	private EventHandler<ActionEvent> onBtnStartGuideClick = new EventHandler<ActionEvent>() {
		@Override
		public void handle(ActionEvent event) {
			hideStartGuide();
		}
	};

	// End of segment: D:\install location\java\work\CS2103 PISTA\src\pista\ui\UIController.java





	/**
	 * origin: D:\install location\java\work\CS2103 PISTA\src\pista\ui\UIController.java
	 */

	/**This method is to handle the click for button undo 
	 * **/
	private EventHandler<ActionEvent> onBtnUndoClick = new EventHandler<ActionEvent>() {
		@Override
		public void handle(ActionEvent event) {
			executeCommand(Constants.UI_UNDO_COMMAND);
		}
	};

	// End of segment: D:\install location\java\work\CS2103 PISTA\src\pista\ui\UIController.java





	/**
	 * origin: D:\install location\java\work\CS2103 PISTA\src\pista\ui\UIController.java
	 */

	/**This method is to handle the click for button redo 
	 * **/
	private EventHandler<ActionEvent> onBtnRedoClick = new EventHandler<ActionEvent>() {
		@Override
		public void handle(ActionEvent event) {
			executeCommand(Constants.UI_REDO_COMMAND);
		}
	};

	// End of segment: D:\install location\java\work\CS2103 PISTA\src\pista\ui\UIController.java





	/**
	 * origin: D:\install location\java\work\CS2103 PISTA\src\pista\ui\UIController.java
	 */

	/**This method is to handle the click for button help
	 * **/
	private EventHandler<ActionEvent> onBtnHelpClick = new EventHandler<ActionEvent>() {
		@Override
		public void handle(ActionEvent event) {
			showHelp();
		}
	};

	// End of segment: D:\install location\java\work\CS2103 PISTA\src\pista\ui\UIController.java





	/**
	 * origin: D:\install location\java\work\CS2103 PISTA\src\pista\ui\UIController.java
	 */

	/**This method is to handle the click for button refresh 
	 * **/
	private EventHandler<ActionEvent> onBtnRefreshClick = new EventHandler<ActionEvent>() {
		@Override
		public void handle(ActionEvent event) {
			initTaskListInListView();
		}
	};

	// End of segment: D:\install location\java\work\CS2103 PISTA\src\pista\ui\UIController.java





	/**
	 * origin: D:\install location\java\work\CS2103 PISTA\src\pista\ui\UIController.java
	 */

	/**This method is to handle the click for button add new task 
	 * **/
	private EventHandler<ActionEvent> onBtnAddNewTaskClick = new EventHandler<ActionEvent>() {
		@Override
		public void handle(ActionEvent event) {
			initPopOverAdd(); //initialize the Pop-over add
			showPopOverAdd(); //open pop-over add
		}
	};

	// End of segment: D:\install location\java\work\CS2103 PISTA\src\pista\ui\UIController.java





	/**
	 * origin: D:\install location\java\work\CS2103 PISTA\src\pista\ui\UIController.java
	 */

	/**This method is to handle the click for button setting
	 * **/
	private EventHandler<ActionEvent> onBtnSettingClick = new EventHandler<ActionEvent>() {
		@Override
		public void handle(ActionEvent event) {
			initPopOverSetting();
			showPopOverSetting(); //open pop-over setting
		}
	};
	
}//end class

	// End of segment: D:\install location\java\work\CS2103 PISTA\src\pista\ui\UIController.java





